name: Publish Release

on:
  workflow_dispatch:
    inputs:
      tag:
        description: "Release tag to build (e.g., v4.0.0-rc.1)"
        required: true
        type: string
      dry_run:
        description: "Prepare artifacts without publishing"
        required: false
        type: boolean
        default: false
      ref:
        description: "Git ref (branch, tag, or commit) to build; defaults to the tag"
        required: false
        type: string
      targets:
        description: "Comma-separated list of release targets (all, python, node, ruby, cli, crates, docker, homebrew, java, csharp)"
        required: false
        type: string
  release:
    types: [published]
  repository_dispatch:
    types: [publish-release]

concurrency:
  group: ${{ github.workflow }}-${{ (github.event_name == 'workflow_dispatch' && (github.event.inputs.ref || github.event.inputs.tag)) || github.ref || github.run_id }}
  cancel-in-progress: false

env:
  CARGO_TERM_COLOR: always
  PDFIUM_VERSION: "7529"
  ORT_VERSION: "1.23.2"
  MACOSX_DEPLOYMENT_TARGET: "14.0"

jobs:
  prepare:
    name: Prepare metadata
    runs-on: ubuntu-latest
    outputs:
      tag: ${{ steps.meta.outputs.tag }}
      version: ${{ steps.meta.outputs.version }}
      ref: ${{ steps.meta.outputs.ref }}
      dry_run: ${{ steps.meta.outputs.dry_run }}
      checkout_ref: ${{ steps.meta.outputs.checkout_ref }}
      target_sha: ${{ steps.meta.outputs.target_sha }}
      matrix_ref: ${{ steps.meta.outputs.matrix_ref }}
      is_tag: ${{ steps.meta.outputs.is_tag }}
      release_targets: ${{ steps.meta.outputs.release_targets }}
      release_any: ${{ steps.meta.outputs.release_any }}
      release_python: ${{ steps.meta.outputs.release_python }}
      release_node: ${{ steps.meta.outputs.release_node }}
      release_ruby: ${{ steps.meta.outputs.release_ruby }}
      release_cli: ${{ steps.meta.outputs.release_cli }}
      release_crates: ${{ steps.meta.outputs.release_crates }}
      release_docker: ${{ steps.meta.outputs.release_docker }}
      release_homebrew: ${{ steps.meta.outputs.release_homebrew }}
      release_java: ${{ steps.meta.outputs.release_java }}
      release_csharp: ${{ steps.meta.outputs.release_csharp }}
    steps:
      - name: Validate tag and compute version
        id: meta
        run: |
          event="${{ github.event_name }}"
          if [[ "$event" == "workflow_dispatch" ]]; then
            tag="${{ inputs.tag }}"
            dry_run_input="${{ inputs.dry_run }}"
            ref_input="${{ inputs.ref }}"
            targets_input="${{ inputs.targets }}"
          elif [[ "$event" == "release" ]]; then
            tag="${{ github.event.release.tag_name }}"
            dry_run_input="false"
            ref_input="refs/tags/${tag}"
            targets_input=""
          elif [[ "$event" == "repository_dispatch" ]]; then
            tag="${{ github.event.client_payload.tag }}"
            dry_run_input="${{ github.event.client_payload.dry_run }}"
            ref_input="${{ github.event.client_payload.ref }}"
            targets_input="${{ github.event.client_payload.targets }}"
          else
            tag="${GITHUB_REF_NAME}"
            dry_run_input="false"
            ref_input=""
            targets_input=""
            if [[ "$tag" == *-pre* || "$tag" == *-rc* ]]; then
              dry_run_input="true"
            fi
          fi
          if [[ -z "$tag" ]]; then
            echo "Release tag could not be determined" >&2
            exit 1
          fi
          if [[ "$tag" != v* ]]; then
            echo "Tag must start with 'v' (e.g., v4.0.0-rc.1)" >&2
            exit 1
          fi
          version="${tag#v}"
          if [[ -n "$ref_input" ]]; then
            ref="$ref_input"
          else
            ref="refs/tags/${tag}"
          fi
          if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
            checkout_ref="refs/heads/main"
            target_sha="$ref"
          elif [[ "$ref" =~ ^refs/ ]]; then
            checkout_ref="$ref"
            target_sha=""
          else
            checkout_ref="refs/heads/${ref}"
            target_sha=""
          fi
          if [[ "$ref" =~ ^[0-9a-f]{40}$ ]]; then
            matrix_ref="main"
          elif [[ "$ref" =~ ^refs/heads/(.+)$ ]]; then
            matrix_ref="${BASH_REMATCH[1]}"
          elif [[ "$ref" =~ ^refs/tags/(.+)$ ]]; then
            matrix_ref="${BASH_REMATCH[1]}"
          else
            matrix_ref="$ref"
          fi
          dry_run="$dry_run_input"

          if [[ "$ref" =~ ^refs/tags/ ]]; then
            is_tag="true"
          else
            is_tag="false"
          fi

          normalize_target_list() {
            local raw="$1"
            raw="${raw:-all}"
            if [[ -z "$raw" ]]; then
              echo "all"
            else
              echo "$raw"
            fi
          }

          targets_value=$(normalize_target_list "$targets_input")
          release_python=false
          release_node=false
          release_ruby=false
          release_cli=false
          release_crates=false
          release_docker=false
          release_homebrew=false
          release_java=false
          release_csharp=false

          set_all_targets() {
            release_python=true
            release_node=true
            release_ruby=true
            release_cli=true
            release_crates=true
            release_docker=true
            release_homebrew=true
            release_java=true
            release_csharp=true
          }

          mapfile -t requested_targets < <(echo "$targets_value" | tr ',' '\n')

          processed_any=false
          for raw_target in "${requested_targets[@]}"; do
            trimmed=$(echo "$raw_target" | tr '[:upper:]' '[:lower:]' | xargs)
            if [[ -z "$trimmed" ]]; then
              continue
            fi
            processed_any=true
            case "$trimmed" in
              all|'*'|'default')
                set_all_targets
                break
                ;;
              python)
                release_python=true
                ;;
              node)
                release_node=true
                ;;
              ruby)
                release_ruby=true
                ;;
              cli)
                release_cli=true
                ;;
              crates)
                release_crates=true
                ;;
              docker)
                release_docker=true
                ;;
              homebrew)
                release_homebrew=true
                ;;
              java)
                release_java=true
                ;;
              csharp|dotnet|cs|nuget)
                release_csharp=true
                ;;
              none)
                release_python=false
                release_node=false
                release_ruby=false
                release_cli=false
                release_crates=false
                release_docker=false
                release_homebrew=false
                release_java=false
                release_csharp=false
                ;;
              *)
                echo "Unknown release target '$trimmed'. Allowed: all, python, node, ruby, cli, crates, docker, homebrew, java, csharp." >&2
                exit 1
                ;;
            esac
          done

          if [[ "$release_homebrew" == "true" ]]; then
            release_cli=true
          fi

          if [[ "$processed_any" == "false" ]]; then
            set_all_targets
            requested_targets=("all")
          fi

          enabled_targets=()
          if [[ "$release_python" == "true" ]]; then enabled_targets+=("python"); fi
          if [[ "$release_node" == "true" ]]; then enabled_targets+=("node"); fi
          if [[ "$release_ruby" == "true" ]]; then enabled_targets+=("ruby"); fi
          if [[ "$release_cli" == "true" ]]; then enabled_targets+=("cli"); fi
          if [[ "$release_crates" == "true" ]]; then enabled_targets+=("crates"); fi
          if [[ "$release_docker" == "true" ]]; then enabled_targets+=("docker"); fi
          if [[ "$release_homebrew" == "true" ]]; then enabled_targets+=("homebrew"); fi
          if [[ "$release_java" == "true" ]]; then enabled_targets+=("java"); fi
          if [[ "$release_csharp" == "true" ]]; then enabled_targets+=("csharp"); fi

          if [[ ${#enabled_targets[@]} -eq 9 ]]; then
            release_targets_summary="all"
          elif [[ ${#enabled_targets[@]} -eq 0 ]]; then
            release_targets_summary="none"
          else
            release_targets_summary=$(IFS=','; echo "${enabled_targets[*]}")
          fi

          release_any="false"
          if [[ ${#enabled_targets[@]} -gt 0 ]]; then
            release_any="true"
          fi

          cat <<JSON > release-metadata.json
          {
            "tag": "$tag",
            "version": "$version",
            "ref": "$ref",
            "checkout_ref": "$checkout_ref",
            "target_sha": "$target_sha",
            "matrix_ref": "$matrix_ref",
            "dry_run": ${dry_run:-false},
            "is_tag": $is_tag,
            "release_targets": "$release_targets_summary",
            "release_any": $release_any,
            "release_python": $release_python,
            "release_node": $release_node,
            "release_ruby": $release_ruby,
            "release_cli": $release_cli,
            "release_crates": $release_crates,
            "release_docker": $release_docker,
            "release_homebrew": $release_homebrew,
            "release_java": $release_java,
            "release_csharp": $release_csharp
          }
          JSON
          echo "tag=$tag" >> "$GITHUB_OUTPUT"
          echo "version=$version" >> "$GITHUB_OUTPUT"
          echo "ref=$ref" >> "$GITHUB_OUTPUT"
          echo "dry_run=${dry_run:-false}" >> "$GITHUB_OUTPUT"
          echo "checkout_ref=$checkout_ref" >> "$GITHUB_OUTPUT"
          echo "target_sha=$target_sha" >> "$GITHUB_OUTPUT"
          echo "matrix_ref=$matrix_ref" >> "$GITHUB_OUTPUT"
          echo "is_tag=$is_tag" >> "$GITHUB_OUTPUT"
          echo "release_targets=$release_targets_summary" >> "$GITHUB_OUTPUT"
          echo "release_any=$release_any" >> "$GITHUB_OUTPUT"
          echo "release_python=$release_python" >> "$GITHUB_OUTPUT"
          echo "release_node=$release_node" >> "$GITHUB_OUTPUT"
          echo "release_ruby=$release_ruby" >> "$GITHUB_OUTPUT"
          echo "release_cli=$release_cli" >> "$GITHUB_OUTPUT"
          echo "release_crates=$release_crates" >> "$GITHUB_OUTPUT"
          echo "release_docker=$release_docker" >> "$GITHUB_OUTPUT"
          echo "release_homebrew=$release_homebrew" >> "$GITHUB_OUTPUT"
          echo "release_java=$release_java" >> "$GITHUB_OUTPUT"
          echo "release_csharp=$release_csharp" >> "$GITHUB_OUTPUT"
          echo "release_csharp=$release_csharp" >> "$GITHUB_OUTPUT"

      - name: Upload release metadata
        uses: actions/upload-artifact@v5
        with:
          name: release-metadata
          path: release-metadata.json
          retention-days: 14

  check-pypi:
    name: Check if Python package exists on PyPI
    needs: prepare
    if: ${{ needs.prepare.outputs.is_tag == 'true' && needs.prepare.outputs.release_python == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      exists: ${{ steps.check.outputs.exists }}
    steps:
      - name: Check PyPI for existing version
        id: check
        run: |
          set -euo pipefail
          version="${{ needs.prepare.outputs.version }}"

          # Check if package version exists on PyPI
          http_code=$(curl -s -o /dev/null -w "%{http_code}" \
            "https://pypi.org/pypi/kreuzberg/${version}/json")

          if [ "$http_code" = "200" ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Python package kreuzberg==${version} already exists on PyPI"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::Python package kreuzberg==${version} not found on PyPI, will build and publish"
          fi

  check-npm:
    name: Check if Node package exists on npm
    needs: prepare
    if: ${{ needs.prepare.outputs.is_tag == 'true' && needs.prepare.outputs.release_node == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      exists: ${{ steps.check.outputs.exists }}
    steps:
      - name: Check npm for existing version
        id: check
        run: |
          set -euo pipefail
          version="${{ needs.prepare.outputs.version }}"
          package="@kreuzberg/node"

          # npm view returns non-zero if version doesn't exist
          if npm view "${package}@${version}" version >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Node package ${package}@${version} already exists on npm"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::Node package ${package}@${version} not found on npm, will build and publish"
          fi

  check-rubygems:
    name: Check if Ruby gem exists on RubyGems
    needs: prepare
    if: ${{ needs.prepare.outputs.is_tag == 'true' && needs.prepare.outputs.release_ruby == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      exists: ${{ steps.check.outputs.exists }}
    steps:
      - name: Check RubyGems for existing version
        id: check
        run: |
          set -euo pipefail
          version="${{ needs.prepare.outputs.version }}"

          # gem search returns versions that exist
          if gem search kreuzberg --remote --exact --version "=${version}" | grep -q "kreuzberg (${version})"; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Ruby gem kreuzberg ${version} already exists on RubyGems"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::Ruby gem kreuzberg ${version} not found on RubyGems, will build and publish"
          fi

  check-maven:
    name: Check if Java package exists on Maven Central
    needs: prepare
    if: ${{ needs.prepare.outputs.is_tag == 'true' && needs.prepare.outputs.release_java == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      exists: ${{ steps.check.outputs.exists }}
    steps:
      - name: Check Maven Central for existing version
        id: check
        run: |
          set -euo pipefail
          version="${{ needs.prepare.outputs.version }}"
          group="dev.kreuzberg"
          artifact="kreuzberg"

          # Query Maven Central REST API
          url="https://search.maven.org/solrsearch/select?q=g:${group}+AND+a:${artifact}+AND+v:${version}&rows=1&wt=json"
          response=$(curl -s "$url")

          count=$(echo "$response" | jq -r '.response.numFound')
          if [ "$count" -gt 0 ]; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Java package ${group}:${artifact}:${version} already exists on Maven Central"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::Java package ${group}:${artifact}:${version} not found on Maven Central, will build and publish"
          fi

  check-nuget:
    name: Check if C# package exists on NuGet
    needs: prepare
    if: ${{ needs.prepare.outputs.is_tag == 'true' && needs.prepare.outputs.release_csharp == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      exists: ${{ steps.check.outputs.exists }}
    steps:
      - name: Check NuGet for existing version
        id: check
        run: |
          set -euo pipefail
          version="${{ needs.prepare.outputs.version }}"
          package="Kreuzberg"

          # Query NuGet API
          url="https://api.nuget.org/v3/registration5-semver1/${package,,}/index.json"
          response=$(curl -s "$url")

          if echo "$response" | jq -e ".items[].items[]?.catalogEntry | select(.version == \"${version}\")" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "::notice::NuGet package ${package} ${version} already exists"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "::notice::NuGet package ${package} ${version} not found, will build and publish"
          fi

  check-cratesio:
    name: Check if Rust crate exists on crates.io
    needs: prepare
    if: ${{ needs.prepare.outputs.is_tag == 'true' }}
    runs-on: ubuntu-latest
    outputs:
      kreuzberg_exists: ${{ steps.check.outputs.kreuzberg_exists }}
      tesseract_exists: ${{ steps.check.outputs.tesseract_exists }}
      cli_exists: ${{ steps.check.outputs.cli_exists }}
      exists: ${{ steps.check.outputs.all_exist }}
    steps:
      - name: Check crates.io for existing versions
        id: check
        run: |
          set -euo pipefail
          version="${{ needs.prepare.outputs.version }}"

          # Check kreuzberg crate
          if cargo search kreuzberg --limit 1 | grep -q "kreuzberg = \"${version}\""; then
            echo "kreuzberg_exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Rust crate kreuzberg ${version} already exists on crates.io"
          else
            echo "kreuzberg_exists=false" >> $GITHUB_OUTPUT
          fi

          # Check kreuzberg-tesseract crate
          if cargo search kreuzberg-tesseract --limit 1 | grep -q "kreuzberg-tesseract = \"${version}\""; then
            echo "tesseract_exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Rust crate kreuzberg-tesseract ${version} already exists on crates.io"
          else
            echo "tesseract_exists=false" >> $GITHUB_OUTPUT
          fi

          # Check kreuzberg-cli crate
          if cargo search kreuzberg-cli --limit 1 | grep -q "kreuzberg-cli = \"${version}\""; then
            echo "cli_exists=true" >> $GITHUB_OUTPUT
            echo "::notice::Rust crate kreuzberg-cli ${version} already exists on crates.io"
          else
            echo "cli_exists=false" >> $GITHUB_OUTPUT
          fi

          # Set all_exist if all three crates exist
          if [ "$(cat $GITHUB_OUTPUT | grep '_exists=true' | wc -l)" -eq 3 ]; then
            echo "all_exist=true" >> $GITHUB_OUTPUT
          else
            echo "all_exist=false" >> $GITHUB_OUTPUT
          fi

  python-wheels:
    name: Build Python wheels (${{ matrix.label }})
    needs: [prepare, check-pypi]
    if: ${{ needs.prepare.outputs.release_python == 'true' && needs.check-pypi.outputs.exists != 'true' }}
    runs-on: ${{ matrix.os }}
    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        include:
          - label: linux-x86_64
            os: ubuntu-latest
            artifact: python-wheels-linux-x86_64
            rust_target: x86_64-unknown-linux-gnu
            manylinux: auto
            python: "3.10"
            needs_qemu: false
            extra_args: ""
          # TODO: Re-enable linux-aarch64 once build issues are resolved
          # - label: linux-aarch64
          #   os: ubuntu-latest
          #   artifact: python-wheels-linux-aarch64
          #   rust_target: aarch64-unknown-linux-gnu
          #   manylinux: 2_28
          #   python: "3.10"
          #   needs_qemu: true
          #   extra_args: ""
          - label: macos-arm64
            os: macos-14
            artifact: python-wheels-macos
            needs_qemu: false
            python: "3.10"
            rust_target: aarch64-apple-darwin
            manylinux: ""
            extra_args: ""
          - label: windows-amd64
            os: windows-latest
            artifact: python-wheels-windows
            needs_qemu: false
            python: "3.10"
            rust_target: x86_64-pc-windows-msvc
            manylinux: ""
            extra_args: ""
    steps:
      - name: Maximize build disk space
        if: matrix.os == 'ubuntu-latest'
        uses: easimon/maximize-build-space@v10
        with:
          root-reserve-mb: 2048
          temp-reserve-mb: 512
          swap-size-mb: 4096
          overprovision-lvm: 'true'
          remove-dotnet: 'true'
          remove-android: 'true'
          remove-haskell: 'true'
          remove-codeql: 'true'
          remove-docker-images: 'true'

      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup QEMU
        if: matrix.os == 'ubuntu-latest' && matrix.needs_qemu
        uses: docker/setup-qemu-action@v3
        with:
          platforms: all

      - name: Cache Pdfium binaries
        if: matrix.os == 'ubuntu-latest' && matrix.needs_qemu
        uses: ./.github/actions/cache-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Download Pdfium runtime
        if: matrix.os == 'ubuntu-latest' && matrix.needs_qemu
        uses: ./.github/actions/download-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Prepare wheel staging directory
        if: matrix.os == 'ubuntu-latest'
        shell: bash
        run: mkdir -p target/wheels

      - name: Setup Tesseract cache
        id: tesseract-cache
        uses: ./.github/actions/setup-tesseract-cache
        with:
          label: ${{ matrix.label }}
          enable-cache: "true"
          rust-target: ${{ matrix.rust_target }}

      - name: Install macOS Rust targets
        if: matrix.label == 'macos-arm64'
        shell: bash
        run: rustup target add aarch64-apple-darwin

      - name: Build Linux wheels
        if: matrix.os == 'ubuntu-latest'
        uses: PyO3/maturin-action@v1
        with:
          command: build
          args: --release -i python${{ matrix.python }} --out ../../target/wheels ${{ matrix.extra_args }}
          target: ${{ matrix.rust_target }}
          manylinux: ${{ matrix.manylinux }}
          working-directory: packages/python
          sccache: ${{ steps.tesseract-cache.outputs.cache-enabled }}
          docker-options: ${{ steps.tesseract-cache.outputs.docker-options }}

      - name: Build wheels (native)
        if: matrix.os != 'ubuntu-latest'
        uses: PyO3/maturin-action@v1
        with:
          command: build
          args: --release -i python${{ matrix.python }} --out ../../target/wheels ${{ matrix.extra_args }}
          target: ${{ matrix.rust_target }}
          working-directory: packages/python
          sccache: ${{ steps.tesseract-cache.outputs.cache-enabled }}

      - name: Setup Python (macOS)
        if: matrix.label == 'macos-arm64'
        uses: actions/setup-python@v6
        with:
          python-version: '3.10'

      - name: Install wheel CLI (macOS)
        if: matrix.label == 'macos-arm64'
        run: python3 -m pip install wheel

      - name: Codesign macOS wheel binaries
        if: matrix.label == 'macos-arm64'
        shell: bash
        env:
          MACOS_CODESIGN_IDENTITY: ${{ secrets.MACOS_CODESIGN_IDENTITY }}
        run: python3 scripts/sign_macos_wheels.py --wheel-dir target/wheels

      - name: List built wheels
        shell: bash
        run: ls -lh target/wheels

      - name: Upload wheel artifact
        uses: actions/upload-artifact@v5
        with:
          name: ${{ matrix.artifact }}
          path: target/wheels/*.whl
          retention-days: 14

  python-sdist:
    name: Build Python sdist
    needs: [prepare, check-pypi]
    if: ${{ needs.prepare.outputs.release_python == 'true' && needs.check-pypi.outputs.exists != 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Python environment
        uses: ./.github/actions/setup-python-env
        with:
          python-version: "3.13"
          cache-prefix: python-sdist

      - name: Setup Rust toolchain
        uses: ./.github/actions/setup-rust
        with:
          cache-key-prefix: publish-python-sdist

      - name: Build sdist
        run: bash scripts/build_python_sdist.sh dist

      - name: Upload sdist
        uses: actions/upload-artifact@v5
        with:
          name: python-sdist
          path: dist/*.tar.gz
          retention-days: 14

  node-bindings:
    name: Build Node bindings (${{ matrix.settings.target }})
    needs: [prepare, check-npm]
    if: ${{ needs.prepare.outputs.release_node == 'true' && needs.check-npm.outputs.exists != 'true' }}
    runs-on: ${{ matrix.settings.os }}
    timeout-minutes: 90
    strategy:
      fail-fast: false
      matrix:
        settings:
          - os: macos-14
            target: aarch64-apple-darwin
            rust_target: ""
            use_cross: false
            use_napi_cross: false
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            rust_target: ""
            use_cross: false
            use_napi_cross: false
          # TODO: Re-enable additional Linux targets once cross-compilation pipeline matches test-build
          # - os: ubuntu-latest
          #   target: aarch64-unknown-linux-gnu
          #   rust_target: aarch64-unknown-linux-gnu
          #   use_cross: false
          #   use_napi_cross: true
          #   use_napi_cross: false
          # - os: ubuntu-latest
          #   target: armv7-unknown-linux-gnueabihf
          #   rust_target: armv7-unknown-linux-gnueabihf
          #   use_cross: false
          #   use_napi_cross: true
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            rust_target: ""
            use_cross: false
            use_napi_cross: false
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          package_json_file: package.json

      - name: Setup Rust toolchain
        uses: ./.github/actions/setup-rust
        with:
          cache-key-prefix: publish-node-${{ matrix.settings.target }}

      - name: Add Rust target
        if: ${{ matrix.settings.rust_target != '' }}
        run: rustup target add ${{ matrix.settings.rust_target }}

      - name: Install cross
        if: ${{ matrix.settings.use_cross }}
        run: cargo install cross --git https://github.com/cross-rs/cross --locked

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          check-latest: true

      - name: Enable corepack
        run: corepack enable

      - name: Prepare ONNX Runtime (macOS)
        if: startsWith(matrix.settings.target, 'aarch64-apple-darwin') || startsWith(matrix.settings.target, 'x86_64-apple-darwin')
        uses: ./.github/actions/setup-prebuilt-onnx
        with:
          target: ${{ matrix.settings.target }}

      - name: Install Node dependencies
        run: |
          corepack enable
          pnpm install -C crates/kreuzberg-node

      - name: Clean npm directory
        if: runner.os != 'Windows'
        run: rm -rf crates/kreuzberg-node/npm

      - name: Clean npm directory (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: Remove-Item -Recurse -Force crates/kreuzberg-node\npm -ErrorAction SilentlyContinue

      - name: Create npm package structure
        run: pnpm --filter @kreuzberg/node exec napi create-npm-dirs

      - name: Build native module
        if: runner.os != 'Windows'
        env:
          TARGET: ${{ matrix.settings.target }}
          USE_CROSS: ${{ matrix.settings.use_cross }}
          USE_NAPI_CROSS: ${{ matrix.settings.use_napi_cross }}
        shell: bash
        run: |
          set -euo pipefail
          args=(--platform --release --target "$TARGET" --output-dir ./artifacts)
          if [ "${USE_NAPI_CROSS}" = "true" ]; then
            args+=(--use-napi-cross)
          fi
          if [ "${USE_CROSS}" = "true" ]; then
            args+=(--use-cross)
          fi
          pnpm --filter @kreuzberg/node exec napi build "${args[@]}"

      - name: Build native module (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          TARGET: ${{ matrix.settings.target }}
          USE_CROSS: ${{ matrix.settings.use_cross }}
          USE_NAPI_CROSS: ${{ matrix.settings.use_napi_cross }}
        run: |
          $args = @('--platform', '--release', '--target', $env:TARGET, '--output-dir', './artifacts')
          if ($env:USE_NAPI_CROSS -eq 'true') { $args += '--use-napi-cross' }
          if ($env:USE_CROSS -eq 'true') { $args += '--use-cross' }
          pnpm --filter @kreuzberg/node exec napi build @args

      - name: Package artifacts
        if: runner.os != 'Windows'
        env:
          TARGET: ${{ matrix.settings.target }}
        shell: bash
        run: |
          set -euo pipefail
          pnpm --filter @kreuzberg/node exec napi artifacts --output-dir ./artifacts
          if [ ! -d crates/kreuzberg-node/npm ]; then
            echo "npm artifact directory missing" >&2
            exit 1
          fi
          tar -czf node-bindings-$TARGET.tar.gz -C crates/kreuzberg-node npm

      - name: Package artifacts (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        env:
          TARGET: ${{ matrix.settings.target }}
        run: |
          pnpm --filter @kreuzberg/node exec napi artifacts --output-dir ./artifacts
          if (-Not (Test-Path crates/kreuzberg-node\npm)) { throw "npm artifact directory missing" }
          tar -czf node-bindings-$env:TARGET.tar.gz -C crates/kreuzberg-node npm

      - name: Generate and upload TypeScript definitions
        if: matrix.settings.target == 'x86_64-unknown-linux-gnu'
        run: |
          pnpm --filter @kreuzberg/node exec napi build --platform --dts index.d.ts
          mkdir -p typescript-defs
          cp crates/kreuzberg-node/index.d.ts typescript-defs/
          cp crates/kreuzberg-node/index.js typescript-defs/ || true

      - name: Upload TypeScript definitions
        if: matrix.settings.target == 'x86_64-unknown-linux-gnu'
        uses: actions/upload-artifact@v5
        with:
          name: node-typescript-defs
          path: typescript-defs
          retention-days: 14

      - name: Upload Node artifact
        uses: actions/upload-artifact@v5
        with:
          name: node-bindings-${{ matrix.settings.target }}
          path: node-bindings-${{ matrix.settings.target }}.tar.gz
          retention-days: 14

  cli-binaries:
    name: Build CLI binaries (${{ matrix.target }})
    needs: prepare
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
            use_cross: false
          # TODO: Re-enable x86_64-unknown-linux-musl once build issues are resolved
          # - os: ubuntu-latest
          #   target: x86_64-unknown-linux-musl
          #   use_cross: false
          # TODO: Add aarch64-unknown-linux-gnu once test-build parity is restored
          # - os: ubuntu-latest
          #   target: aarch64-unknown-linux-gnu
          #   use_cross: false
          - os: macos-14
            target: aarch64-apple-darwin
            use_cross: false
          - os: windows-latest
            target: x86_64-pc-windows-msvc
            use_cross: false
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust toolchain
        uses: ./.github/actions/setup-rust
        with:
          target: ${{ matrix.target }}
          cache-key-prefix: publish-cli-${{ matrix.target }}

      - name: Add compilation target
        run: rustup target add ${{ matrix.target }}

      - name: Install build dependencies
        if: runner.os == 'Linux'
        run: |
          set -euo pipefail
          sudo apt-get update
          case "${{ matrix.target }}" in
            aarch64-unknown-linux-gnu)
              sudo apt-get install -y gcc-aarch64-linux-gnu
              ;;
          esac

      - name: Configure cross linker
        if: ${{ matrix.target == 'aarch64-unknown-linux-gnu' }}
        run: |
          {
            echo "CC_aarch64_unknown_linux_gnu=aarch64-linux-gnu-gcc"
            echo "CXX_aarch64_unknown_linux_gnu=aarch64-linux-gnu-g++"
            echo "AR_aarch64_unknown_linux_gnu=aarch64-linux-gnu-ar"
            echo "CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc"
          } >> "$GITHUB_ENV"

      - name: Build CLI
        run: bash scripts/build_cli_binary.sh ${{ matrix.target }}

      - name: Package CLI artifact
        if: runner.os != 'Windows'
        run: bash scripts/package_cli_artifact.sh ${{ matrix.target }}

      - name: Package CLI artifact (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $target = '${{ matrix.target }}'
          $stage = "kreuzberg-cli-$target"
          Remove-Item -Recurse -Force $stage -ErrorAction SilentlyContinue
          New-Item -ItemType Directory -Path $stage | Out-Null
          Copy-Item "target/$target/release/kreuzberg.exe" $stage
          Copy-Item LICENSE $stage
          Copy-Item README.md $stage

          # Copy shared libraries if they exist
          if (Test-Path "target/$target/release/pdfium.dll") {
            Copy-Item "target/$target/release/pdfium.dll" $stage
          }

          Compress-Archive -Path "$stage/*" -DestinationPath "$stage.zip" -Force
          Remove-Item -Recurse -Force $stage

      - name: Upload CLI artifact
        if: runner.os != 'Windows'
        uses: actions/upload-artifact@v5
        with:
          name: cli-${{ matrix.target }}
          path: kreuzberg-cli-${{ matrix.target }}.tar.gz
          retention-days: 14

      - name: Upload CLI artifact (Windows)
        if: runner.os == 'Windows'
        uses: actions/upload-artifact@v5
        with:
          name: cli-${{ matrix.target }}
          path: kreuzberg-cli-${{ matrix.target }}.zip
          retention-days: 14

  ruby-gem:
    name: Build Ruby gem (${{ matrix.label }})
    needs: [prepare, check-rubygems]
    if: ${{ needs.prepare.outputs.release_ruby == 'true' && needs.check-rubygems.outputs.exists != 'true' }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: ubuntu-latest
            label: linux
          - os: macos-14
            label: macos-arm64
          - os: windows-latest
            label: windows-x64
    runs-on: ${{ matrix.os }}
    timeout-minutes: 60
    env:
      RB_SYS_CARGO_PROFILE: release
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Install MSYS2 toolchain
        if: runner.os == 'Windows'
        shell: pwsh
        run: ridk exec pacman -S --needed --noconfirm base-devel mingw-w64-ucrt-x86_64-toolchain

      - name: Install Rust (GNU on Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: rustup toolchain install stable-gnu --profile minimal --no-self-update

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.3"
          bundler: "2.5.12"
          bundler-cache: false

      - name: Configure bindgen compatibility headers (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $includeRoot = "$env:GITHUB_WORKSPACE\packages\ruby\ext\kreuzberg_rb\native\include"
          $compat = "$includeRoot\msvc_compat"
          $includeRoot = $includeRoot -replace '\\','/'
          $compatForward = $compat -replace '\\','/'

          if (-not $env:RI_DEVKIT) {
            throw "RI_DEVKIT environment variable is not set"
          }
          $msysPrefix = ridk exec bash -lc 'printf %s "$MSYSTEM_PREFIX"'
          $msysPrefix = $msysPrefix.Trim()
          $riDevkit = $env:RI_DEVKIT -replace '\\','/'
          $sysroot = "$riDevkit$msysPrefix"

          $extra = "-I$includeRoot -I$compatForward -fms-extensions -fstack-protector-strong -fno-omit-frame-pointer -fno-fast-math --target=x86_64-pc-windows-gnu --sysroot=$sysroot"
          Add-Content -Path $env:GITHUB_ENV -Value "BINDGEN_EXTRA_CLANG_ARGS=$extra"
          Add-Content -Path $env:GITHUB_ENV -Value "BINDGEN_EXTRA_CLANG_ARGS_x86_64-pc-windows-msvc=$extra"
          Add-Content -Path $env:GITHUB_ENV -Value "BINDGEN_EXTRA_CLANG_ARGS_x86_64_pc_windows_msvc=$extra"

      - name: Cache Pdfium binaries
        uses: ./.github/actions/cache-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Download Pdfium runtime
        uses: ./.github/actions/download-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Stage Pdfium runtime artifacts
        uses: ./.github/actions/stage-pdfium-runtime
        with:
          destination: packages/ruby/ext/kreuzberg_rb/native
          additional-destinations: |
            packages/ruby
            packages/ruby/lib

      - name: Download ONNX Runtime (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $ortVersion = "${{ env.ORT_VERSION }}"
          $ortDir = Join-Path $env:RUNNER_TEMP "onnxruntime\x86_64-pc-windows-gnu"
          if (-Not (Test-Path (Join-Path $ortDir "onnxruntime-win-x64-$ortVersion\lib\onnxruntime.dll"))) {
            New-Item -ItemType Directory -Force -Path $ortDir | Out-Null
            $zipPath = Join-Path $ortDir "onnxruntime.zip"
            $url = "https://github.com/microsoft/onnxruntime/releases/download/v$ortVersion/onnxruntime-win-x64-$ortVersion.zip"
            Invoke-WebRequest -Uri $url -OutFile $zipPath -UseBasicParsing
            Expand-Archive -Path $zipPath -DestinationPath $ortDir -Force
          }
          $onnxRoot = Get-ChildItem -Path $ortDir -Directory | Where-Object { $_.Name -like "onnxruntime-win-x64-*" } | Select-Object -First 1
          if (-not $onnxRoot) { throw "ONNX Runtime archive not found" }
          $envLines = @(
            "ORT_STRATEGY=system",
            "ORT_LIB_LOCATION=$($onnxRoot.FullName)\lib",
            "ORT_SKIP_DOWNLOAD=1",
            "ORT_PREFER_DYNAMIC_LINK=1",
            "ORT_DYLIB_PATH=$($onnxRoot.FullName)\lib"
          )
          $envLines | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          $onnxRoot.FullName | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Install Ruby dependencies (Unix)
        if: runner.os != 'Windows'
        env:
          BUNDLE_CMD: "bundle _2.5.12_"
          SKIP_BUNDLE_PATH: "true"
        run: bash scripts/install_ruby_dependencies.sh packages/ruby

      - name: Install Ruby dependencies (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $workspace = ridk exec bash -lc "cygpath -au '$env:GITHUB_WORKSPACE'"
          $gemdir = "$workspace/packages/ruby"
          ridk exec bash -lc "cd $gemdir && export RUSTUP_TOOLCHAIN=stable-gnu CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ && bundle _2.5.12_ install --jobs 4 --retry 3"

      - name: Vendor kreuzberg core crate
        shell: bash
        run: |
          set -euo pipefail
          echo "Copying kreuzberg core crate to vendor directory..."
          rm -rf packages/ruby/vendor/kreuzberg
          mkdir -p packages/ruby/vendor
          cp -R crates/kreuzberg packages/ruby/vendor/kreuzberg

          # Clean up test artifacts and caches that shouldn't be in the gem
          rm -rf packages/ruby/vendor/kreuzberg/.fastembed_cache
          rm -rf packages/ruby/vendor/kreuzberg/target
          find packages/ruby/vendor/kreuzberg -name '*.swp' -delete
          find packages/ruby/vendor/kreuzberg -name '*.bak' -delete
          find packages/ruby/vendor/kreuzberg -name '*.tmp' -delete
          find packages/ruby/vendor/kreuzberg -name '*~' -delete

          echo "Vendor files prepared successfully"

      - name: Build gem (Unix)
        if: runner.os != 'Windows'
        shell: bash
        working-directory: packages/ruby
        run: |
          set -euo pipefail
          bundle _2.5.12_ exec rake clean
          bundle _2.5.12_ exec rake build

      - name: Build gem (Windows)
        if: runner.os == 'Windows'
        shell: pwsh
        run: |
          $workspace = ridk exec bash -lc "cygpath -au '$env:GITHUB_WORKSPACE'"
          $gemdir = "$workspace/packages/ruby"
          ridk exec bash -lc "cd $gemdir && export RUSTUP_TOOLCHAIN=stable-gnu CC=x86_64-w64-mingw32-gcc CXX=x86_64-w64-mingw32-g++ && bundle _2.5.12_ exec rake clean && bundle _2.5.12_ exec rake build"

      - name: Upload gem artifacts
        uses: actions/upload-artifact@v5
        with:
          name: rubygems-${{ matrix.label }}
          path: packages/ruby/pkg/*.gem
          retention-days: 14

  java-package:
    name: Build Java package
    needs: [prepare, check-maven]
    if: ${{ needs.prepare.outputs.release_java == 'true' && needs.check-maven.outputs.exists != 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    env:
      PDFIUM_VERSION: "7529"
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Install system dependencies
        uses: ./.github/actions/install-system-deps

      - name: Setup OpenSSL
        uses: ./.github/actions/setup-openssl

      - name: Setup Rust
        uses: ./.github/actions/setup-rust
        with:
          cache-key-prefix: publish-java

      - name: Setup Java
        uses: actions/setup-java@v5
        with:
          distribution: 'temurin'
          java-version: '25'
          cache: 'maven'

      - name: Cache PDFium
        uses: ./.github/actions/cache-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Download PDFium
        uses: ./.github/actions/download-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Setup ONNX Runtime
        uses: ./.github/actions/setup-onnx-runtime
        with:
          ort-version: ${{ env.ORT_VERSION }}

      - name: Build and package
        working-directory: packages/java
        run: mvn clean package -DskipTests

      - name: Upload JAR artifact
        uses: actions/upload-artifact@v5
        with:
          name: maven-packages
          path: packages/java/target/*.jar
          retention-days: 14

  csharp-package:
    name: Build C# package
    needs: [prepare, check-nuget]
    if: ${{ needs.prepare.outputs.release_csharp == 'true' && needs.check-nuget.outputs.exists != 'true' }}
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "10.x"

      - name: Restore C# dependencies
        run: dotnet restore packages/csharp/Kreuzberg/Kreuzberg.csproj

      - name: Build C# bindings
        run: dotnet build packages/csharp/Kreuzberg/Kreuzberg.csproj -c Release --no-restore

      - name: Pack NuGet package
        run: |
          dotnet pack packages/csharp/Kreuzberg/Kreuzberg.csproj \
            -c Release \
            --no-build \
            -p:PackageVersion=${{ needs.prepare.outputs.version }} \
            -o artifacts/csharp

      - name: Upload NuGet artifact
        uses: actions/upload-artifact@v5
        with:
          name: csharp-nuget
          path: artifacts/csharp/*.nupkg
          retention-days: 14

  cargo-packages:
    name: Package Rust crates
    needs: prepare
    # DISABLED: crates.io packaging disabled due to git dependencies (fastembed-rs, ort)
    # cargo package validates crates.io compatibility even without publishing
    if: false
    runs-on: ubuntu-latest
    timeout-minutes: 30
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Setup Rust toolchain
        uses: ./.github/actions/setup-rust
        with:
          cache-key-prefix: publish-cargo-packages

      - name: Package crates
        env:
          RELEASE_VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail

          # Package tesseract first (no dependencies)
          tesseract_packaged=0
          tesseract_status=0
          cargo package -p kreuzberg-tesseract --allow-dirty || tesseract_status=$?

          if [ "$tesseract_status" -eq 0 ]; then
            tesseract_packaged=1
          else
            echo "::warning::Skipping kreuzberg-tesseract crate packaging."
          fi

          # Package kreuzberg (depends on tesseract if feature enabled)
          cargo package -p kreuzberg --allow-dirty

          # Package CLI (depends on kreuzberg)
          cli_packaged=0
          cli_status=0
          cargo package -p kreuzberg-cli --allow-dirty --no-verify || cli_status=$?

          if [ "$cli_status" -eq 0 ]; then
            cli_packaged=1
          else
            echo "::warning::Skipping kreuzberg-cli crate packaging; kreuzberg ${RELEASE_VERSION:-unknown} is not yet available on crates.io."
          fi

          mkdir -p crate-artifacts
          if [ "$tesseract_packaged" -eq 1 ]; then
            cp target/package/kreuzberg-tesseract-*.crate crate-artifacts/
          fi
          cp target/package/kreuzberg-*.crate crate-artifacts/
          if [ "$cli_packaged" -eq 1 ]; then
            cp target/package/kreuzberg-cli-*.crate crate-artifacts/
          fi

      - name: Upload crate packages
        uses: actions/upload-artifact@v5
        with:
          name: cargo-crates
          path: crate-artifacts/*.crate
          retention-days: 14

  publish-docker:
    name: Publish Docker image (${{ matrix.variant }})
    needs:
      - prepare
    runs-on: ubuntu-latest
    timeout-minutes: 180
    permissions:
      contents: read
      packages: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - variant: core
            dockerfile: docker/Dockerfile.core
            image: goldziher/kreuzberg
            tag_suffix: "-core"
            extra_tag: "core"
          - variant: full
            dockerfile: docker/Dockerfile.full
            image: goldziher/kreuzberg
            tag_suffix: ""
            extra_tag: "latest"
    steps:
      - name: Skip Docker release
        if: ${{ needs.prepare.outputs.release_docker != 'true' }}
        run: |
          echo "Docker release disabled via workflow targets (${{ needs.prepare.outputs.release_targets }})."

      - name: Free up disk space
        if: ${{ needs.prepare.outputs.release_docker == 'true' }}
        run: |
          echo "Initial disk usage:"
          df -h /
          sudo rm -rf /usr/share/dotnet /usr/local/lib/android /opt/ghc /opt/hostedtoolcache/CodeQL
          sudo rm -rf /usr/local/share/boost /usr/local/lib/node_modules /opt/microsoft /usr/local/.ghcup
          sudo apt-get clean
          sudo rm -rf /var/lib/apt/lists/*
          docker system prune -af --volumes || true
          docker builder prune -af || true
          echo "Disk usage after cleanup:"
          df -h /

      - name: Checkout
        if: ${{ needs.prepare.outputs.release_docker == 'true' }}
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive

      - name: Ensure target commit
        if: ${{ needs.prepare.outputs.release_docker == 'true' && needs.prepare.outputs.target_sha != '' }}
        run: git checkout --progress --force ${{ needs.prepare.outputs.target_sha }}

      - name: Set up QEMU
        if: ${{ needs.prepare.outputs.release_docker == 'true' }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: ${{ needs.prepare.outputs.release_docker == 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Build AMD64 test image
        if: ${{ needs.prepare.outputs.release_docker == 'true' }}
        run: |
          docker build \
            -f ${{ matrix.dockerfile }} \
            --build-arg PDFIUM_VERSION=${{ env.PDFIUM_VERSION }} \
            -t kreuzberg-publish:${{ matrix.variant }}-test \
            .

      - name: Run Docker feature tests
        if: ${{ needs.prepare.outputs.release_docker == 'true' }}
        run: |
          ./scripts/test_docker.sh \
            --skip-build \
            --image kreuzberg-publish:${{ matrix.variant }}-test \
            --variant ${{ matrix.variant }} \
            --verbose

      - name: Log in to Docker Hub
        if: ${{ needs.prepare.outputs.release_docker == 'true' && needs.prepare.outputs.dry_run != 'true' }}
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract Docker metadata
        if: ${{ needs.prepare.outputs.release_docker == 'true' && needs.prepare.outputs.dry_run != 'true' }}
        id: docker_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ matrix.image }}
          tags: |
            type=raw,value=${{ needs.prepare.outputs.version }}${{ matrix.tag_suffix }}
            type=raw,value=${{ matrix.extra_tag }}

      - name: Build and push multi-arch image
        if: ${{ needs.prepare.outputs.release_docker == 'true' && needs.prepare.outputs.dry_run != 'true' }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ${{ matrix.dockerfile }}
          push: true
          build-args: |
            PDFIUM_VERSION=${{ env.PDFIUM_VERSION }}
          tags: ${{ steps.docker_meta.outputs.tags }}
          labels: ${{ steps.docker_meta.outputs.labels }}
          platforms: linux/amd64,linux/arm64

      - name: Docker dry-run summary
        if: ${{ needs.prepare.outputs.release_docker == 'true' && needs.prepare.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; Docker image ${{ matrix.image }}:${{ needs.prepare.outputs.version }}${{ matrix.tag_suffix }} tested but not pushed." >> "$GITHUB_STEP_SUMMARY"

      - name: Clean up local Docker images
        if: ${{ always() && needs.prepare.outputs.release_docker == 'true' }}
        run: docker rmi kreuzberg-publish:${{ matrix.variant }}-test || true

  upload-cli-release:
    name: Upload CLI binaries to GitHub Release
    needs: [prepare, cli-binaries]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_cli == 'true' &&
      needs.cli-binaries.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Ensure GitHub release exists
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare.outputs.tag }}"
          if ! gh release view "$tag" >/dev/null 2>&1; then
            gh release create "$tag" --title "$tag" --generate-notes
          fi

      - name: Download CLI artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: cli-*
          path: dist/cli
          merge-multiple: true

      - name: Upload CLI binaries (idempotent)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for file in dist/cli/kreuzberg-cli-*; do
            gh release upload "${{ needs.prepare.outputs.tag }}" "$file" --clobber
          done

  upload-csharp-release:
    name: Upload C# NuGet to GitHub Release
    needs: [prepare, csharp-package]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_csharp == 'true' &&
      needs.csharp-package.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Ensure GitHub release exists
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          tag="${{ needs.prepare.outputs.tag }}"
          if ! gh release view "$tag" >/dev/null 2>&1; then
            gh release create "$tag" --title "$tag" --generate-notes
          fi

      - name: Download C# artifacts
        uses: actions/download-artifact@v6
        with:
          name: csharp-nuget
          path: dist/csharp

      - name: Upload C# packages (idempotent)
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          for file in dist/csharp/*.nupkg; do
            gh release upload "${{ needs.prepare.outputs.tag }}" "$file" --clobber
          done

  publish-crates:
    name: Publish crates.io packages
    needs: [prepare, check-cratesio]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_rust == 'true' &&
      needs.check-cratesio.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Setup Rust toolchain
        uses: ./.github/actions/setup-rust
        with:
          cache-key-prefix: publish-crates

      - name: Verify Cargo.toml version matches tag
        run: |
          cargo_version=$(grep '^\[workspace.package\]' -A 10 Cargo.toml | grep '^version = ' | head -1 | sed -E 's/version = "(.*)"/\1/')
          tag_version="${{ needs.prepare.outputs.version }}"
          if [ "$cargo_version" != "$tag_version" ]; then
            echo "Version mismatch! Cargo: $cargo_version, tag: $tag_version" >&2
            exit 1
          fi
          echo "Cargo.toml version matches tag: $cargo_version"

      - name: Check crates.io for existing release
        id: crate_check
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          python - <<'PY' >> "$GITHUB_OUTPUT"
          import json
          import os
          import sys
          import urllib.request
          version = os.environ["VERSION"]
          crates = [
              ("kreuzberg-tesseract", "tesseract_exists"),
              ("kreuzberg", "core_exists"),
              ("kreuzberg-cli", "cli_exists"),
          ]
          for crate, key in crates:
              url = f"https://crates.io/api/v1/crates/{crate}"
              try:
                  with urllib.request.urlopen(url) as resp:
                      data = json.load(resp)
              except Exception as exc:
                  print(f"::warning::{crate}: failed to query crates.io ({exc})", file=sys.stderr)
                  exists = False
              else:
                  versions = [item.get("num") for item in data.get("versions", [])]
                  exists = version in versions
                  message = "already" if exists else "not yet"
                  print(f"::notice::{crate} {version} {message} published", file=sys.stderr)
              print(f"{key}={'true' if exists else 'false'}")
          PY

      - name: Publish kreuzberg-tesseract
        if: ${{ steps.crate_check.outputs.tesseract_exists != 'true' && needs.prepare.outputs.dry_run != 'true' }}
        env:
          CARGO_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "$CARGO_TOKEN" ]; then
            echo "::error::CARGO_TOKEN secret not set"
            exit 1
          fi
          publish_log=$(mktemp)
          set +e
          cargo publish -p kreuzberg-tesseract --token "$CARGO_TOKEN" 2>&1 | tee "$publish_log"
          status=${PIPESTATUS[0]}
          set -e
          if [ "$status" -ne 0 ]; then
            if grep -qi "already uploaded" "$publish_log"; then
              echo "::notice::kreuzberg-tesseract already published; skipping."
              echo "kreuzberg-tesseract already published; skipping." >> $GITHUB_STEP_SUMMARY
            else
              exit "$status"
            fi
          fi

      - name: Wait for tesseract indexing
        if: ${{ steps.crate_check.outputs.tesseract_exists != 'true' && needs.prepare.outputs.dry_run != 'true' }}
        run: sleep 60

      - name: Publish kreuzberg
        if: ${{ steps.crate_check.outputs.core_exists != 'true' && needs.prepare.outputs.dry_run != 'true' }}
        env:
          CARGO_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "$CARGO_TOKEN" ]; then
            echo "::error::CARGO_TOKEN secret not set"
            exit 1
          fi
          publish_log=$(mktemp)
          set +e
          cargo publish -p kreuzberg --token "$CARGO_TOKEN" 2>&1 | tee "$publish_log"
          status=${PIPESTATUS[0]}
          set -e
          if [ "$status" -ne 0 ]; then
            if grep -qi "already uploaded" "$publish_log"; then
              echo "::notice::kreuzberg already published; skipping."
              echo "kreuzberg already published; skipping." >> $GITHUB_STEP_SUMMARY
            else
              exit "$status"
            fi
          fi

      - name: Wait for indexing
        if: ${{ steps.crate_check.outputs.core_exists != 'true' && needs.prepare.outputs.dry_run != 'true' }}
        run: sleep 30

      - name: Publish kreuzberg-cli
        if: ${{ steps.crate_check.outputs.cli_exists != 'true' && needs.prepare.outputs.dry_run != 'true' }}
        env:
          CARGO_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
        run: |
          set -euo pipefail
          if [ -z "$CARGO_TOKEN" ]; then
            echo "::error::CARGO_TOKEN secret not set"
            exit 1
          fi
          publish_log=$(mktemp)
          set +e
          cargo publish -p kreuzberg-cli --token "$CARGO_TOKEN" 2>&1 | tee "$publish_log"
          status=${PIPESTATUS[0]}
          set -e
          if [ "$status" -ne 0 ]; then
            if grep -qi "already uploaded" "$publish_log"; then
              echo "::notice::kreuzberg-cli already published; skipping."
              echo "kreuzberg-cli already published; skipping." >> $GITHUB_STEP_SUMMARY
            else
              exit "$status"
            fi
          fi

      - name: Crates dry-run summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; cargo publish skipped." >> "$GITHUB_STEP_SUMMARY"

  publish-pypi:
    name: Publish Python packages to PyPI
    needs: [prepare, check-pypi, python-wheels, python-sdist]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_python == 'true' &&
      needs.check-pypi.outputs.exists != 'true' &&
      needs.python-wheels.result == 'success' &&
      needs.python-sdist.result == 'success'
    runs-on: ubuntu-latest
    environment: pypi
    permissions:
      id-token: write
    steps:
      - name: Download wheel artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: python-wheels-*
          path: dist
          merge-multiple: true

      - name: Download sdist artifact
        uses: actions/download-artifact@v6
        with:
          name: python-sdist
          path: dist

      - name: List artifacts
        run: ls -R dist

      - name: Publish to PyPI
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          packages-dir: dist
          skip-existing: true

      - name: Dry run summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; artifacts staged for PyPI:" >> $GITHUB_STEP_SUMMARY
          ls -1 dist >> $GITHUB_STEP_SUMMARY

  publish-rubygems:
    name: Publish Ruby gems
    needs: [prepare, check-rubygems, ruby-gem]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_ruby == 'true' &&
      needs.check-rubygems.outputs.exists != 'true' &&
      needs.ruby-gem.result == 'success'
    runs-on: ubuntu-latest
    permissions:
      id-token: write
    steps:
      - name: Download Ruby gem artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: rubygems-*
          path: dist
          merge-multiple: true

      - name: Configure trusted publishing credentials
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        uses: rubygems/configure-rubygems-credentials@v1.0.0
        with:
          api-token: ${{ secrets.RUBYGEMS_API_KEY }}

      - name: Verify RubyGems credentials
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        run: |
          if [ ! -f ~/.gem/credentials ]; then
            echo "::error::RubyGems credentials file not found at ~/.gem/credentials"
            ls -la ~/.gem/ || echo "~/.gem directory does not exist"
            exit 1
          fi
          chmod 600 ~/.gem/credentials

      - name: Check RubyGems version
        id: rubygems_check
        run: |
          set -euo pipefail
          export VERSION="${{ needs.prepare.outputs.version }}"
          exists=$(python3 - <<'PY'
          import json, os, sys, urllib.request
          version = os.environ["VERSION"]
          try:
              with urllib.request.urlopen("https://rubygems.org/api/v1/versions/kreuzberg.json") as resp:
                  data = json.load(resp)
              print("true" if any(entry.get("number") == version for entry in data) else "false")
          except urllib.error.HTTPError as e:
              if e.code == 404:
                  print("::notice::Gem kreuzberg not found on RubyGems (first publish)", file=sys.stderr)
                  print("false")
              else:
                  raise
          PY
          )
          echo "exists=$exists" >> "$GITHUB_OUTPUT"

      - name: Publish gems
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.rubygems_check.outputs.exists != 'true' }}
        working-directory: dist
        run: |
          set -euo pipefail
          shopt -s nullglob
          gems=($(ls kreuzberg-*.gem | sort))
          if [ ${#gems[@]} -eq 0 ]; then
            echo "No gem artifacts found" >&2
            exit 1
          fi
          for gem in "${gems[@]}"; do
            echo "Pushing ${gem}"
            gem push "$gem"
          done

      - name: Ruby gem already published
        if: ${{ steps.rubygems_check.outputs.exists == 'true' }}
        run: echo "RubyGem version ${{ needs.prepare.outputs.version }} already published; skipping." >> $GITHUB_STEP_SUMMARY

      - name: Dry run summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        working-directory: dist
        run: |
          echo "Dry run requested; gem artifacts ready:" >> $GITHUB_STEP_SUMMARY
          ls -1 kreuzberg-*.gem >> $GITHUB_STEP_SUMMARY

  publish-node:
    name: Publish Node packages
    needs: [prepare, check-npm, node-bindings]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_node == 'true' &&
      needs.check-npm.outputs.exists != 'true' &&
      needs.node-bindings.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          package_json_file: package.json

      - name: Download Node artifacts
        uses: actions/download-artifact@v6
        with:
          pattern: node-bindings-*
          path: node-artifacts
          merge-multiple: true

      - name: Download TypeScript definitions
        uses: actions/download-artifact@v6
        with:
          name: node-typescript-defs
          path: typescript-defs
          if-no-files-found: ignore

      - name: Setup Node
        uses: actions/setup-node@v6
        with:
          node-version: 20
          registry-url: https://registry.npmjs.org/

      - name: Enable corepack
        run: corepack enable

      - name: Prepare artifact directory
        run: |
          set -euo pipefail
          rm -rf crates/kreuzberg-node/npm
          mkdir -p crates/kreuzberg-node/npm
          shopt -s nullglob
          for pkg in node-artifacts/*.tar.gz; do
            echo "Unpacking $pkg"
            tmpdir=$(mktemp -d)
            tar -xzf "$pkg" -C "$tmpdir"
            if [ ! -d "$tmpdir/npm" ]; then
              echo "::warning::npm directory missing inside $pkg"
              rm -rf "$tmpdir"
              continue
            fi
            while IFS= read -r -d '' dir; do
              name=$(basename "$dir")
              dest="crates/kreuzberg-node/npm/$name"
              rm -rf "$dest"
              cp -R "$dir" "$dest"
            done < <(find "$tmpdir/npm" -mindepth 1 -maxdepth 1 -type d -print0)
            rm -rf "$tmpdir"
          done
          if [ -d typescript-defs ]; then
            cp typescript-defs/index.js typescript-defs/index.d.ts crates/kreuzberg-node/ || true
          fi

      - name: Node artifacts summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; Node binding tarballs staged:" >> "$GITHUB_STEP_SUMMARY"
          find node-artifacts -name '*.tar.gz' -print >> "$GITHUB_STEP_SUMMARY"

      - name: Install workspace dependencies
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        run: pnpm install -C crates/kreuzberg-node

      - name: Pack platform packages
        run: |
          cd crates/kreuzberg-node/npm
          for dir in */; do
            if [ -f "$dir/package.json" ]; then
              (cd "$dir" && npm pack && mv *.tgz ..)
            fi
          done

      - name: Publish native binary packages
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          set -euo pipefail
          shopt -s nullglob
          for pkg in crates/kreuzberg-node/npm/*.tgz; do
            echo "Publishing $pkg"
            publish_log=$(mktemp)
            set +e
            npm publish "$pkg" --access public --ignore-scripts 2>&1 | tee "$publish_log"
            status=${PIPESTATUS[0]}
            set -e
            if [ "$status" -ne 0 ]; then
              if grep -q "previously published versions" "$publish_log"; then
                echo "::notice::Package $pkg already published; skipping."
                echo "Package $(basename "$pkg") already published; skipping." >> $GITHUB_STEP_SUMMARY
              else
                exit "$status"
              fi
            fi
          done

      - name: Wait for npm indexing
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        run: sleep 30

      - name: Publish main Node package
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: |
          cd crates/kreuzberg-node
          publish_log=$(mktemp)
          set +e
          pnpm publish --access public --no-git-checks 2>&1 | tee "$publish_log"
          status=${PIPESTATUS[0]}
          set -e
          if [ "$status" -ne 0 ]; then
            if grep -q "previously published versions" "$publish_log"; then
              echo "::notice::kreuzberg-node already published; skipping."
              echo "kreuzberg-node already published; skipping." >> $GITHUB_STEP_SUMMARY
            else
              exit "$status"
            fi
          fi

  publish-maven:
    name: Publish Maven packages
    needs: [prepare, check-maven, java-package]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_java == 'true' &&
      needs.check-maven.outputs.exists != 'true' &&
      needs.java-package.result == 'success'
    runs-on: ubuntu-latest
    env:
      PDFIUM_VERSION: "7529"
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          ref: ${{ needs.prepare.outputs.ref }}

      - name: Check Maven Central for existing release
        id: maven_check
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        env:
          VERSION: ${{ needs.prepare.outputs.version }}
        run: |
          set -euo pipefail
          exists=$(python3 - <<'PY'
          import json, os, sys
          try:
              import urllib.request
              version = os.environ["VERSION"]
              url = f"https://search.maven.org/solrsearch/select?q=g:dev.kreuzberg+AND+a:kreuzberg+AND+v:{version}&rows=1&wt=json"
              with urllib.request.urlopen(url) as resp:
                  data = json.load(resp)
              exists = data.get("response", {}).get("numFound", 0) > 0
              print("true" if exists else "false")
          except Exception as e:
              print(f"::warning::Failed to query Maven Central: {e}", file=sys.stderr)
              print("false")
          PY
          )
          echo "exists=$exists" >> "$GITHUB_OUTPUT"
          if [ "$exists" = "true" ]; then
            echo "::notice::Maven package version ${{ needs.prepare.outputs.version }} already published."
          fi

      - name: Install system dependencies
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        uses: ./.github/actions/install-system-deps

      - name: Setup OpenSSL
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        uses: ./.github/actions/setup-openssl

      - name: Setup Rust
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        uses: ./.github/actions/setup-rust
        with:
          cache-key-prefix: publish-maven

      - name: Patch legacy Maven GPG arguments
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        run: |
          set -euo pipefail
          if grep -q '<arg>--pinentry-mode</arg>' packages/java/pom.xml; then
            sed -i 's/<arg>--pinentry-mode<\/arg>\s*<arg>loopback<\/arg>/<arg>--pinentry-mode=loopback<\/arg>/g' packages/java/pom.xml
            echo "Patched legacy GPG pinentry argument format in packages/java/pom.xml" >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Setup Java
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        env:
          NEXUS_USERNAME: ${{ secrets.NEXUS_USERNAME }}
          NEXUS_PASSWORD: ${{ secrets.NEXUS_PASSWORD }}
          MAVEN_GPG_PASSPHRASE: ${{ secrets.GPP_PASSPHRASE }}
        uses: actions/setup-java@v5
        with:
          distribution: temurin
          java-version: "25"
          cache: maven
          server-id: central
          server-username: NEXUS_USERNAME
          server-password: NEXUS_PASSWORD
          gpg-private-key: ${{ secrets.GPG_PRIVATE_KEY }}
          gpg-passphrase: MAVEN_GPG_PASSPHRASE

      - name: Cache PDFium
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        uses: ./.github/actions/cache-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Download PDFium
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        uses: ./.github/actions/download-pdfium
        with:
          pdfium-version: ${{ env.PDFIUM_VERSION }}

      - name: Prefer gpg2 binary
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        run: |
          set -euo pipefail
          if command -v gpg2 >/dev/null 2>&1; then
            mkdir -p "${HOME}/.local/bin"
            printf '#!/usr/bin/env bash\nexec gpg2 "$@"\n' > "${HOME}/.local/bin/gpg"
            chmod +x "${HOME}/.local/bin/gpg"
            echo "${HOME}/.local/bin" >> "$GITHUB_PATH"
            echo "PATH=${HOME}/.local/bin:${PATH}" >> "$GITHUB_ENV"
          fi

      - name: Release Maven package
        if: ${{ needs.prepare.outputs.dry_run != 'true' && steps.maven_check.outputs.exists != 'true' }}
        run: |
          set -euo pipefail
          mvn -f packages/java/pom.xml --batch-mode --no-transfer-progress clean deploy

      - name: Maven already published summary
        if: ${{ steps.maven_check.outputs.exists == 'true' }}
        run: echo "Maven package version ${{ needs.prepare.outputs.version }} already published; skipping." >> $GITHUB_STEP_SUMMARY

      - name: Dry run summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        run: echo "Dry run requested; Maven publish skipped." >> "$GITHUB_STEP_SUMMARY"

  publish-nuget:
    name: Publish NuGet package
    needs: [prepare, check-nuget, csharp-package]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_csharp == 'true' &&
      needs.check-nuget.outputs.exists != 'true' &&
      needs.csharp-package.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Download NuGet artifact
        uses: actions/download-artifact@v6
        with:
          name: csharp-nuget
          path: dist

      - name: Setup .NET
        uses: actions/setup-dotnet@v5
        with:
          dotnet-version: "10.x"

      - name: Publish to NuGet
        if: ${{ needs.prepare.outputs.dry_run != 'true' }}
        run: |
          dotnet nuget push "dist/*.nupkg" \
            --source https://api.nuget.org/v3/index.json \
            --api-key "${{ secrets.NUGET_API_KEY }}" \
            --skip-duplicate
          echo "NuGet package published." >> $GITHUB_STEP_SUMMARY

      - name: Dry run summary
        if: ${{ needs.prepare.outputs.dry_run == 'true' }}
        run: |
          echo "Dry run requested; NuGet publish skipped." >> "$GITHUB_STEP_SUMMARY"
          ls -1 dist/*.nupkg >> "$GITHUB_STEP_SUMMARY"

  publish-homebrew:
    name: Update Homebrew formula
    needs: [prepare, upload-cli-release]
    if: |
      always() &&
      needs.prepare.outputs.dry_run != 'true' &&
      needs.prepare.outputs.is_tag == 'true' &&
      needs.prepare.outputs.release_homebrew == 'true' &&
      needs.upload-cli-release.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Extract release info
        id: release
        run: |
          tag="${{ needs.prepare.outputs.tag }}"
          version="${{ needs.prepare.outputs.version }}"
          url="https://github.com/Goldziher/kreuzberg/archive/$tag.tar.gz"

          echo "tag=$tag" >> $GITHUB_OUTPUT
          echo "version=$version" >> $GITHUB_OUTPUT
          echo "url=$url" >> $GITHUB_OUTPUT

          echo "Release info:"
          echo "  Tag: $tag"
          echo "  Version: $version"
          echo "  URL: $url"

      - name: Update Homebrew formula
        uses: mislav/bump-homebrew-formula-action@v3
        with:
          formula-name: kreuzberg
          formula-path: Formula/kreuzberg.rb
          homebrew-tap: Goldziher/homebrew-tap
          tag-name: ${{ needs.prepare.outputs.tag }}
          download-url: ${{ steps.release.outputs.url }}
          commit-message: |
            chore(homebrew): update kreuzberg to ${{ steps.release.outputs.version }}

            Auto-update from release ${{ steps.release.outputs.tag }}
        env:
          COMMITTER_TOKEN: ${{ secrets.HOMEBREW_TOKEN }}

  release-finalize:
    name: Finalize release and update notes
    needs:
      - prepare
      - check-pypi
      - check-npm
      - check-rubygems
      - check-maven
      - check-nuget
      - check-cratesio
      - publish-pypi
      - publish-node
      - publish-rubygems
      - publish-maven
      - publish-nuget
      - publish-homebrew
      - publish-docker
      - upload-cli-release
      - upload-csharp-release
    if: always() && needs.prepare.outputs.is_tag == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Aggregate release status
        id: status
        run: |
          python3 - <<'EOF'
          import os

          # Registry check results
          registry_checks = {
              "Python (PyPI)": "${{ needs.check-pypi.outputs.exists }}",
              "Node (npm)": "${{ needs.check-npm.outputs.exists }}",
              "Ruby (RubyGems)": "${{ needs.check-rubygems.outputs.exists }}",
              "Java (Maven)": "${{ needs.check-maven.outputs.exists }}",
              "C# (NuGet)": "${{ needs.check-nuget.outputs.exists }}",
          }

          # Publish job results
          publish_results = {
              "Python (PyPI)": "${{ needs.publish-pypi.result }}",
              "Node (npm)": "${{ needs.publish-node.result }}",
              "Ruby (RubyGems)": "${{ needs.publish-rubygems.result }}",
              "Java (Maven)": "${{ needs.publish-maven.result }}",
              "C# (NuGet)": "${{ needs.publish-nuget.result }}",
              "Homebrew": "${{ needs.publish-homebrew.result }}",
              "Docker": "${{ needs.publish-docker.result }}",
              "CLI Release": "${{ needs.upload-cli-release.result }}",
              "C# Release": "${{ needs.upload-csharp-release.result }}",
          }

          summary_lines = ["## Release Status for ${{ needs.prepare.outputs.tag }}", ""]

          # Already published (skipped)
          skipped = [k for k, v in registry_checks.items() if v == "true"]
          if skipped:
              summary_lines.append("###   Already Published (Skipped)")
              for item in skipped:
                  summary_lines.append(f"- {item}")
              summary_lines.append("")

          # Newly published
          success = [k for k, v in publish_results.items() if v == "success"]
          if success:
              summary_lines.append("###  Published Successfully")
              for item in success:
                  summary_lines.append(f"- {item}")
              summary_lines.append("")

          # Failed
          failed = [k for k, v in publish_results.items() if v == "failure"]
          if failed:
              summary_lines.append("###  Failed")
              for item in failed:
                  summary_lines.append(f"- {item}")
              summary_lines.append("")

          # Skipped due to conditions
          skipped_cond = [k for k, v in publish_results.items() if v == "skipped"]
          if skipped_cond:
              summary_lines.append("###  Skipped (Not Enabled)")
              for item in skipped_cond:
                  summary_lines.append(f"- {item}")
              summary_lines.append("")

          summary = "\n".join(summary_lines)

          with open(os.environ["GITHUB_STEP_SUMMARY"], "a") as f:
              f.write(summary + "\n")

          with open(os.environ["GITHUB_OUTPUT"], "a") as f:
              escaped = summary.replace("%", "%25").replace("\n", "%0A")
              f.write(f"release_summary={escaped}\n")
          EOF

