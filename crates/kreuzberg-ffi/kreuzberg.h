/* Auto-generated C bindings for Kreuzberg */

#ifndef KREUZBERG_FFI_H
#define KREUZBERG_FFI_H

#pragma once

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
/**
 * Opaque type for extraction configuration.
 * This is an opaque pointer type - callers should not access its internals.
 */
typedef struct ExtractionConfig ExtractionConfig;


/**
 * C-compatible extraction result structure
 *
 * Must be kept in sync with the Java side's MemoryLayout definition in KreuzbergFFI.java
 * Field order: 11 pointers (8 bytes each) + 1 bool + 7 bytes padding = 96 bytes total
 */
typedef struct CExtractionResult {
  /**
   * Extracted text content (null-terminated UTF-8 string, must be freed with kreuzberg_free_string)
   */
  char *content;
  /**
   * Detected MIME type (null-terminated string, must be freed with kreuzberg_free_string)
   */
  char *mime_type;
  /**
   * Document language (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *language;
  /**
   * Document date (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *date;
  /**
   * Document subject (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *subject;
  /**
   * Tables as JSON array (null-terminated string, or NULL if no tables, must be freed with kreuzberg_free_string)
   */
  char *tables_json;
  /**
   * Detected languages as JSON array (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *detected_languages_json;
  /**
   * Metadata as JSON object (null-terminated string, or NULL if no metadata, must be freed with kreuzberg_free_string)
   */
  char *metadata_json;
  /**
   * Text chunks as JSON array (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *chunks_json;
  /**
   * Extracted images as JSON array (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *images_json;
  /**
   * Page structure as JSON object (null-terminated string, or NULL if not available, must be freed with kreuzberg_free_string)
   */
  char *page_structure_json;
  /**
   * Whether extraction was successful
   */
  bool success;
  /**
   * Padding to match Java MemoryLayout (7 bytes padding to align to 8-byte boundary)
   */
  uint8_t _padding1[7];
} CExtractionResult;

/**
 * C-compatible structure for batch extraction results
 *
 * Must be kept in sync with the Java side's MemoryLayout definition in KreuzbergFFI.java
 * Field order: 1 pointer (8 bytes) + 1 usize (8 bytes) + 1 bool + 7 bytes padding = 24 bytes total
 */
typedef struct CBatchResult {
  /**
   * Array of extraction results
   */
  struct CExtractionResult **results;
  /**
   * Number of results
   */
  uintptr_t count;
  /**
   * Whether batch operation was successful
   */
  bool success;
  /**
   * Padding to match Java MemoryLayout (7 bytes padding to align to 8-byte boundary)
   */
  uint8_t _padding2[7];
} CBatchResult;

/**
 * C-compatible structure for passing byte array with MIME type in batch operations
 *
 * Must be kept in sync with the Java side's MemoryLayout definition in KreuzbergFFI.java
 * Field order: 1 pointer (8 bytes) + 1 usize (8 bytes) + 1 pointer (8 bytes) = 24 bytes total
 */
typedef struct CBytesWithMime {
  /**
   * Pointer to byte data
   */
  const uint8_t *data;
  /**
   * Length of byte data
   */
  uintptr_t data_len;
  /**
   * MIME type as null-terminated C string
   */
  const char *mime_type;
} CBytesWithMime;

/**
 * Type alias for the OCR backend callback function.
 *
 * # Parameters
 *
 * - `image_bytes`: Pointer to image data
 * - `image_length`: Length of image data in bytes
 * - `config_json`: JSON-encoded OcrConfig (null-terminated string)
 *
 * # Returns
 *
 * Null-terminated string containing extracted text (must be freed by Rust via kreuzberg_free_string),
 * or NULL on error.
 *
 * # Safety
 *
 * The callback must:
 * - Not store the image_bytes pointer (it's only valid for the duration of the call)
 * - Return a valid null-terminated UTF-8 string allocated by the caller
 * - Return NULL on error (error message should be retrievable separately)
 */
typedef char *(*OcrBackendCallback)(const uint8_t *image_bytes,
                                    uintptr_t image_length,
                                    const char *config_json);

/**
 * Type alias for the PostProcessor callback function.
 *
 * # Parameters
 *
 * - `result_json`: JSON-encoded ExtractionResult (null-terminated string)
 *
 * # Returns
 *
 * Null-terminated JSON string containing the processed ExtractionResult
 * (must be freed by Rust via kreuzberg_free_string), or NULL on error.
 *
 * # Safety
 *
 * The callback must:
 * - Not store the result_json pointer (it's only valid for the duration of the call)
 * - Return a valid null-terminated UTF-8 JSON string allocated by the caller
 * - Return NULL on error (error message should be retrievable separately)
 */
typedef char *(*PostProcessorCallback)(const char *result_json);

/**
 * Type alias for the DocumentExtractor callback function.
 *
 * # Parameters
 *
 * - `content`: Raw document bytes
 * - `content_len`: Length of the content array
 * - `mime_type`: MIME type of the document (null-terminated string)
 * - `config_json`: JSON-encoded ExtractionConfig (null-terminated string)
 *
 * # Returns
 *
 * Null-terminated JSON string containing the ExtractionResult, or NULL on error.
 * The returned string must be freeable by kreuzberg_free_string.
 *
 * # Safety
 *
 * The callback must:
 * - Not store the content, mime_type, or config_json pointers (only valid during the call)
 * - Return a valid null-terminated UTF-8 JSON string or NULL on error
 * - The returned string must be freeable by kreuzberg_free_string
 */
typedef char *(*DocumentExtractorCallback)(const uint8_t *content,
                                           uintptr_t content_len,
                                           const char *mime_type,
                                           const char *config_json);

/**
 * Type alias for the Validator callback function.
 *
 * # Parameters
 *
 * - `result_json`: JSON-encoded ExtractionResult (null-terminated string)
 *
 * # Returns
 *
 * Null-terminated error message string if validation fails (must be freed by Rust
 * via kreuzberg_free_string), or NULL if validation passes.
 *
 * # Safety
 *
 * The callback must:
 * - Not store the result_json pointer (it's only valid for the duration of the call)
 * - Return a valid null-terminated UTF-8 string (error message) if validation fails
 * - Return NULL if validation passes
 * - The returned string must be freeable by kreuzberg_free_string
 */
typedef char *(*ValidatorCallback)(const char *result_json);

/**
 * Extract text and metadata from a file (synchronous).
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const char* path = "/path/to/document.pdf";
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     printf("MIME: %s\n", result->mime_type);
 *     kreuzberg_free_result(result);
 * } else {
 *     const char* error = kreuzberg_last_error();
 *     printf("Error: %s\n", error);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_file_sync(const char *file_path);

/**
 * Detect MIME type from a file path.
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 */
char *kreuzberg_detect_mime_type(const char *file_path, bool check_exists);

/**
 * Validate that a MIME type is supported by Kreuzberg.
 *
 * # Safety
 *
 * - `mime_type` must be a valid null-terminated C string
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 */
char *kreuzberg_validate_mime_type(const char *mime_type);

/**
 * List available embedding preset names.
 *
 * # Safety
 *
 * - Returned string is a JSON array and must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 */
char *kreuzberg_list_embedding_presets(void);

/**
 * Get a specific embedding preset by name.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - Returned string is JSON object and must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 */
char *kreuzberg_get_embedding_preset(const char *name);

/**
 * Extract text and metadata from a file with custom configuration (synchronous).
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const char* path = "/path/to/document.pdf";
 * const char* config = "{\"force_ocr\": true, \"ocr\": {\"language\": \"deu\"}}";
 * CExtractionResult* result = kreuzberg_extract_file_sync_with_config(path, config);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     kreuzberg_free_result(result);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_file_sync_with_config(const char *file_path,
                                                                  const char *config_json);

/**
 * Extract text and metadata from byte array (synchronous).
 *
 * # Safety
 *
 * - `data` must be a valid pointer to a byte array of length `data_len`
 * - `mime_type` must be a valid null-terminated C string
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const uint8_t* data = ...; // Document bytes
 * size_t len = ...;           // Length of data
 * const char* mime = "application/pdf";
 * CExtractionResult* result = kreuzberg_extract_bytes_sync(data, len, mime);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     kreuzberg_free_result(result);
 * } else {
 *     const char* error = kreuzberg_last_error();
 *     printf("Error: %s\n", error);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_bytes_sync(const uint8_t *data,
                                                       uintptr_t data_len,
                                                       const char *mime_type);

/**
 * Extract text and metadata from byte array with custom configuration (synchronous).
 *
 * # Safety
 *
 * - `data` must be a valid pointer to a byte array of length `data_len`
 * - `mime_type` must be a valid null-terminated C string
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 *
 * # Example (C)
 *
 * ```c
 * const uint8_t* data = ...; // Document bytes
 * size_t len = ...;           // Length of data
 * const char* mime = "application/pdf";
 * const char* config = "{\"force_ocr\": true, \"ocr\": {\"language\": \"deu\"}}";
 * CExtractionResult* result = kreuzberg_extract_bytes_sync_with_config(data, len, mime, config);
 * if (result != NULL && result->success) {
 *     printf("Content: %s\n", result->content);
 *     kreuzberg_free_result(result);
 * }
 * ```
 */
struct CExtractionResult *kreuzberg_extract_bytes_sync_with_config(const uint8_t *data,
                                                                   uintptr_t data_len,
                                                                   const char *mime_type,
                                                                   const char *config_json);

/**
 * Batch extract text and metadata from multiple files (synchronous).
 *
 * # Safety
 *
 * - `file_paths` must be a valid pointer to an array of null-terminated C strings
 * - `count` must be the number of file paths in the array
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_batch_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 */
struct CBatchResult *kreuzberg_batch_extract_files_sync(const char *const *file_paths,
                                                        uintptr_t count,
                                                        const char *config_json);

/**
 * Batch extract text and metadata from multiple byte arrays (synchronous).
 *
 * # Safety
 *
 * - `items` must be a valid pointer to an array of CBytesWithMime structures
 * - `count` must be the number of items in the array
 * - `config_json` must be a valid null-terminated C string containing JSON, or NULL for default config
 * - The returned pointer must be freed with `kreuzberg_free_batch_result`
 * - Returns NULL on error (check `kreuzberg_last_error` for details)
 */
struct CBatchResult *kreuzberg_batch_extract_bytes_sync(const struct CBytesWithMime *items,
                                                        uintptr_t count,
                                                        const char *config_json);

/**
 * Load an extraction configuration from a TOML/YAML/JSON file.
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 */
char *kreuzberg_load_extraction_config_from_file(const char *file_path);

/**
 * Free a batch result returned by batch extraction functions.
 *
 * # Safety
 *
 * - `batch_result` must be a pointer previously returned by a batch extraction function
 * - `batch_result` can be NULL (no-op)
 * - `batch_result` must not be used after this call
 * - All results and strings within the batch result will be freed automatically
 */
void kreuzberg_free_batch_result(struct CBatchResult *batch_result);

/**
 * Free a string returned by Kreuzberg functions.
 *
 * # Safety
 *
 * - `s` must be a string previously returned by a Kreuzberg function
 * - `s` can be NULL (no-op)
 * - `s` must not be used after this call
 *
 * # Example (C)
 *
 * ```c
 * char* str = result->content;
 * kreuzberg_free_string(str);
 * // str is now invalid
 * ```
 */
void kreuzberg_free_string(char *s);

/**
 * Clone a null-terminated string using Rust's allocator.
 *
 * # Safety
 *
 * - `s` must be a valid null-terminated UTF-8 string
 * - Returned pointer must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 */
char *kreuzberg_clone_string(const char *s);

/**
 * Free an extraction result returned by `kreuzberg_extract_file_sync`.
 *
 * # Safety
 *
 * - `result` must be a pointer previously returned by `kreuzberg_extract_file_sync`
 * - `result` can be NULL (no-op)
 * - `result` must not be used after this call
 * - All string fields within the result will be freed automatically
 *
 * # Example (C)
 *
 * ```c
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * // Use result...
 * kreuzberg_free_result(result);
 * // result is now invalid
 * ```
 */
void kreuzberg_free_result(struct CExtractionResult *result);

/**
 * Get the last error message from a failed operation.
 *
 * # Safety
 *
 * - Returns a static string that does not need to be freed
 * - Returns NULL if no error has occurred
 * - The returned string is valid until the next Kreuzberg function call on the same thread
 *
 * # Example (C)
 *
 * ```c
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * if (result == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     if (error != NULL) {
 *         printf("Error: %s\n", error);
 *     }
 * }
 * ```
 */
const char *kreuzberg_last_error(void);

/**
 * Get the error code for the last error.
 *
 * Returns the error code as an i32. Error codes are defined in ErrorCode enum:
 * - 0: Success (no error)
 * - 1: GenericError
 * - 2: Panic
 * - 3: InvalidArgument
 * - 4: IoError
 * - 5: ParsingError
 * - 6: OcrError
 * - 7: MissingDependency
 *
 * # Safety
 *
 * This function is thread-safe and always safe to call.
 *
 * # Example (C)
 *
 * ```c
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * if (result == NULL) {
 *     int32_t code = kreuzberg_last_error_code();
 *     if (code == 2) {
 *         // A panic occurred
 *     }
 * }
 * ```
 */
int32_t kreuzberg_last_error_code(void);

/**
 * Get the panic context for the last error (if it was a panic).
 *
 * Returns a JSON string containing panic context information, or NULL if
 * the last error was not a panic.
 *
 * The JSON structure contains:
 * - file: Source file where panic occurred
 * - line: Line number
 * - function: Function name
 * - message: Panic message
 * - timestamp_secs: Unix timestamp (seconds since epoch)
 *
 * # Safety
 *
 * The returned string must be freed with kreuzberg_free_string().
 *
 * # Example (C)
 *
 * ```c
 * CExtractionResult* result = kreuzberg_extract_file_sync(path);
 * if (result == NULL && kreuzberg_last_error_code() == 2) {
 *     const char* context = kreuzberg_last_panic_context();
 *     if (context != NULL) {
 *         printf("Panic context: %s\n", context);
 *         kreuzberg_free_string((char*)context);
 *     }
 * }
 * ```
 */
char *kreuzberg_last_panic_context(void);

/**
 * Get the library version string.
 *
 * # Safety
 *
 * - Returns a static string that does not need to be freed
 * - The returned string is always valid
 *
 * # Example (C)
 *
 * ```c
 * const char* version = kreuzberg_version();
 * printf("Kreuzberg version: %s\n", version);
 * ```
 */
const char *kreuzberg_version(void);

/**
 * Register a custom OCR backend via FFI callback.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `callback` must be a valid function pointer that:
 *   - Does not store the image_bytes pointer
 *   - Returns a null-terminated UTF-8 string or NULL on error
 *   - The returned string must be freeable by kreuzberg_free_string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * char* my_ocr_backend(const uint8_t* image_bytes, size_t image_length, const char* config_json) {
 *     // Implement OCR logic here
 *     // Return allocated string with result, or NULL on error
 *     return strdup("Extracted text");
 * }
 *
 * bool success = kreuzberg_register_ocr_backend("my-ocr", my_ocr_backend);
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to register: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_register_ocr_backend(const char *name, OcrBackendCallback callback);

/**
 * Register a custom OCR backend with explicit language support via FFI callback.
 *
 * # Safety
 *
 * - `languages_json` must be a null-terminated JSON array of language codes or NULL
 * - See `kreuzberg_register_ocr_backend` for additional safety notes.
 */
bool kreuzberg_register_ocr_backend_with_languages(const char *name,
                                                   OcrBackendCallback callback,
                                                   const char *languages_json);

/**
 * Register a custom PostProcessor via FFI callback.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `callback` must be a valid function pointer that:
 *   - Does not store the result_json pointer
 *   - Returns a null-terminated UTF-8 JSON string or NULL on error
 *   - The returned string must be freeable by kreuzberg_free_string
 * - `priority` determines the order of execution (higher priority runs first)
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * char* my_post_processor(const char* result_json) {
 *     // Parse result_json, modify it, return JSON string
 *     return strdup("{\"content\":\"PROCESSED\"}");
 * }
 *
 * bool success = kreuzberg_register_post_processor("my-processor", my_post_processor, 100);
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to register: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_register_post_processor(const char *name,
                                       PostProcessorCallback callback,
                                       int32_t priority);

/**
 * Register a custom PostProcessor with an explicit processing stage.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `stage` must be a valid null-terminated C string containing "early", "middle", or "late"
 * - `callback` must be a valid function pointer that:
 *   - Does not store the result_json pointer
 *   - Returns a null-terminated UTF-8 JSON string or NULL on error
 *   - The returned string must be freeable by kreuzberg_free_string
 * - `priority` determines the order of execution within the stage (higher priority runs first)
 * - Returns true on success, false on error (check kreuzberg_last_error)
 */
bool kreuzberg_register_post_processor_with_stage(const char *name,
                                                  PostProcessorCallback callback,
                                                  int32_t priority,
                                                  const char *stage);

/**
 * Unregister a PostProcessor by name.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_unregister_post_processor("my-processor");
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to unregister: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_unregister_post_processor(const char *name);

/**
 * Clear all registered PostProcessors.
 *
 * # Safety
 *
 * - Removes all registered processors. Subsequent extractions will run without them.
 * - Returns true on success, false on error.
 */
bool kreuzberg_clear_post_processors(void);

/**
 * List all registered PostProcessors as a JSON array of names.
 *
 * # Safety
 *
 * - Returned string must be freed with `kreuzberg_free_string`.
 * - Returns NULL on error (check `kreuzberg_last_error`).
 */
char *kreuzberg_list_post_processors(void);

/**
 * Register a custom DocumentExtractor via FFI callback.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `callback` must be a valid function pointer that:
 *   - Does not store the content, mime_type, or config_json pointers
 *   - Returns a null-terminated UTF-8 JSON string or NULL on error
 *   - The returned string must be freeable by kreuzberg_free_string
 * - `mime_types` must be a valid null-terminated C string containing comma-separated MIME types
 * - `priority` determines the order of selection (higher priority preferred)
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * char* my_extractor(const uint8_t* content, size_t len, const char* mime_type, const char* config) {
 *     // Extract content from bytes, return JSON ExtractionResult
 *     return strdup("{\"content\":\"extracted text\",\"mime_type\":\"text/plain\",\"metadata\":{}}");
 * }
 *
 * bool success = kreuzberg_register_document_extractor(
 *     "my-extractor",
 *     my_extractor,
 *     "application/x-custom,text/x-custom",
 *     100
 * );
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to register: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_register_document_extractor(const char *name,
                                           DocumentExtractorCallback callback,
                                           const char *mime_types,
                                           int32_t priority);

/**
 * Unregister a DocumentExtractor by name.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_unregister_document_extractor("my-extractor");
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to unregister: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_unregister_document_extractor(const char *name);

/**
 * List all registered DocumentExtractors as a JSON array of names.
 *
 * # Safety
 *
 * - Returned string must be freed with `kreuzberg_free_string`.
 * - Returns NULL on error (check `kreuzberg_last_error`).
 */
char *kreuzberg_list_document_extractors(void);

/**
 * Register a custom Validator via FFI callback.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - `callback` must be a valid function pointer that:
 *   - Does not store the result_json pointer
 *   - Returns a null-terminated UTF-8 string (error message) if validation fails
 *   - Returns NULL if validation passes
 *   - The returned string must be freeable by kreuzberg_free_string
 * - `priority` determines the order of validation (higher priority runs first)
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * char* my_validator(const char* result_json) {
 *     // Parse result_json, validate it
 *     // Return error message if validation fails, NULL if passes
 *     if (invalid) {
 *         return strdup("Validation failed: content too short");
 *     }
 *     return NULL;
 * }
 *
 * bool success = kreuzberg_register_validator("my-validator", my_validator, 100);
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to register: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_register_validator(const char *name, ValidatorCallback callback, int32_t priority);

/**
 * Unregister a Validator by name.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_unregister_validator("my-validator");
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to unregister: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_unregister_validator(const char *name);

/**
 * Clear all registered Validators.
 *
 * # Safety
 *
 * - Removes all validators. Subsequent extractions will skip custom validation.
 * - Returns true on success, false on error.
 */
bool kreuzberg_clear_validators(void);

/**
 * List all registered Validators as a JSON array of names.
 *
 * # Safety
 *
 * - Returned string must be freed with `kreuzberg_free_string`.
 * - Returns NULL on error (check `kreuzberg_last_error`).
 */
char *kreuzberg_list_validators(void);

/**
 * Unregister an OCR backend by name.
 *
 * # Safety
 *
 * - `name` must be a valid null-terminated C string
 * - Returns true on success, false on error (check kreuzberg_last_error)
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_unregister_ocr_backend("custom-ocr");
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to unregister: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_unregister_ocr_backend(const char *name);

/**
 * List all registered OCR backends as a JSON array of names.
 *
 * # Safety
 *
 * - Returned string must be freed with `kreuzberg_free_string`.
 * - Returns NULL on error (check `kreuzberg_last_error`).
 *
 * # Example (C)
 *
 * ```c
 * char* backends = kreuzberg_list_ocr_backends();
 * if (backends == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to list backends: %s\n", error);
 * } else {
 *     printf("OCR backends: %s\n", backends);
 *     kreuzberg_free_string(backends);
 * }
 * ```
 */
char *kreuzberg_list_ocr_backends(void);

/**
 * Clear all registered OCR backends.
 *
 * # Safety
 *
 * - Removes all registered OCR backends. Subsequent extractions will use only built-in backends.
 * - Returns true on success, false on error.
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_clear_ocr_backends();
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to clear OCR backends: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_clear_ocr_backends(void);

/**
 * Clear all registered DocumentExtractors.
 *
 * # Safety
 *
 * - Removes all registered extractors. Subsequent extractions will use only built-in extractors.
 * - Returns true on success, false on error.
 *
 * # Example (C)
 *
 * ```c
 * bool success = kreuzberg_clear_document_extractors();
 * if (!success) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to clear document extractors: %s\n", error);
 * }
 * ```
 */
bool kreuzberg_clear_document_extractors(void);

/**
 * Detect MIME type from raw bytes.
 *
 * # Safety
 *
 * - `bytes` must be a valid pointer to byte data
 * - `len` must be the correct length of the byte array
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 *
 * # Example (C)
 *
 * ```c
 * const char* pdf_bytes = "%PDF-1.4\n";
 * char* mime = kreuzberg_detect_mime_type_from_bytes((const uint8_t*)pdf_bytes, strlen(pdf_bytes));
 * if (mime == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to detect MIME type: %s\n", error);
 * } else {
 *     printf("MIME type: %s\n", mime);
 *     kreuzberg_free_string(mime);
 * }
 * ```
 */
char *kreuzberg_detect_mime_type_from_bytes(const uint8_t *bytes, uintptr_t len);

/**
 * Detect MIME type from file path (checks extension and reads file content).
 *
 * # Safety
 *
 * - `file_path` must be a valid null-terminated C string
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 *
 * # Example (C)
 *
 * ```c
 * char* mime = kreuzberg_detect_mime_type_from_path("document.pdf");
 * if (mime == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to detect MIME type: %s\n", error);
 * } else {
 *     printf("MIME type: %s\n", mime);
 *     kreuzberg_free_string(mime);
 * }
 * ```
 */
char *kreuzberg_detect_mime_type_from_path(const char *file_path);

/**
 * Get file extensions for a MIME type.
 *
 * # Safety
 *
 * - `mime_type` must be a valid null-terminated C string
 * - The returned string is a JSON array of extensions (must be freed with `kreuzberg_free_string`)
 * - Returns NULL on error (check `kreuzberg_last_error`)
 *
 * # Example (C)
 *
 * ```c
 * char* extensions = kreuzberg_get_extensions_for_mime("application/pdf");
 * if (extensions == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to get extensions: %s\n", error);
 * } else {
 *     printf("Extensions: %s\n", extensions);
 *     kreuzberg_free_string(extensions);
 * }
 * ```
 */
char *kreuzberg_get_extensions_for_mime(const char *mime_type);

/**
 * Load an ExtractionConfig from a file.
 *
 * Automatically detects the file format based on extension:
 * - `.toml` - TOML format
 * - `.yaml`, `.yml` - YAML format
 * - `.json` - JSON format
 *
 * # Safety
 *
 * - `path` must be a valid null-terminated C string representing a file path
 * - Returns a pointer to ExtractionConfig on success, NULL on error
 * - The returned config must be freed with `kreuzberg_free_config`
 * - Check `kreuzberg_last_error` on NULL return
 *
 * # Example (C)
 *
 * ```c
 * ExtractionConfig* config = kreuzberg_config_from_file("kreuzberg.toml");
 * if (config == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     printf("Failed to load config: %s\n", error);
 *     return 1;
 * }
 *
 * // Use config...
 * char* result = kreuzberg_extract_file_with_config_sync("document.pdf", config);
 *
 * kreuzberg_free_config(config);
 * ```
 */
ExtractionConfig *kreuzberg_config_from_file(const char *path);

/**
 * Discover and load an ExtractionConfig by searching parent directories.
 *
 * Searches the current directory and all parent directories for:
 * - `kreuzberg.toml`
 * - `kreuzberg.yaml`
 * - `kreuzberg.yml`
 * - `kreuzberg.json`
 *
 * Returns the first config file found as JSON, or NULL if none found.
 *
 * # Safety
 *
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL if no config found or on error (check `kreuzberg_last_error`)
 *
 * # Example (C)
 *
 * ```c
 * char* config_json = kreuzberg_config_discover();
 * if (config_json == NULL) {
 *     const char* error = kreuzberg_last_error();
 *     if (error != NULL && strlen(error) > 0) {
 *         printf("Error discovering config: %s\n", error);
 *         return 1;
 *     }
 *     // No config found, use defaults
 *     printf("No config file found\n");
 * } else {
 *     printf("Config: %s\n", config_json);
 *     kreuzberg_free_string(config_json);
 * }
 * ```
 */
char *kreuzberg_config_discover(void);

/**
 * Get supported languages for an OCR backend.
 *
 * Returns a JSON array of supported language codes for the given backend.
 * Supported backends: "easyocr", "paddleocr", "tesseract"
 *
 * # Safety
 *
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL if backend not found or on error (check `kreuzberg_last_error`)
 *
 * # Example (C)
 *
 * ```c
 * char* languages = kreuzberg_get_ocr_languages("easyocr");
 * if (languages != NULL) {
 *     printf("EasyOCR languages: %s\n", languages);
 *     kreuzberg_free_string(languages);
 * }
 * ```
 */
char *kreuzberg_get_ocr_languages(const char *backend);

/**
 * Check if a language is supported by an OCR backend.
 *
 * Returns 1 (true) if the language is supported, 0 (false) otherwise.
 *
 * # Arguments
 *
 * * `backend` - Backend name (e.g., "easyocr", "paddleocr", "tesseract")
 * * `language` - Language code to check
 *
 * # Returns
 *
 * 1 if supported, 0 if not supported or backend not found.
 *
 * # Example (C)
 *
 * ```c
 * int is_supported = kreuzberg_is_language_supported("easyocr", "en");
 * if (is_supported) {
 *     printf("English is supported by EasyOCR\n");
 * }
 * ```
 *
 * # Safety
 *
 * - `backend` and `language` must be valid pointers to valid UTF-8 C strings.
 * - Both pointers can be checked for NULL; returns 0 if either is NULL.
 * - The C strings must remain valid for the duration of the function call.
 */
int32_t kreuzberg_is_language_supported(const char *backend, const char *language);

/**
 * Get list of all registered OCR backends with language support.
 *
 * Returns a JSON object mapping backend names to language counts.
 * Example: `{"easyocr": 80, "paddleocr": 14, "tesseract": 100}`
 *
 * # Safety
 *
 * - The returned string must be freed with `kreuzberg_free_string`
 * - Returns NULL on error (check `kreuzberg_last_error`)
 *
 * # Example (C)
 *
 * ```c
 * char* backends = kreuzberg_list_ocr_backends_with_languages();
 * if (backends != NULL) {
 *     printf("Available backends: %s\n", backends);
 *     kreuzberg_free_string(backends);
 * }
 * ```
 */
char *kreuzberg_list_ocr_backends_with_languages(void);

/**
 * Parse an ExtractionConfig from a JSON string.
 *
 * This is the primary FFI entry point for all language bindings to parse
 * configuration from JSON. Replaces the need for each binding to implement
 * its own JSON parsing logic.
 *
 * # Arguments
 *
 * * `json_config` - Null-terminated C string containing JSON configuration
 *
 * # Returns
 *
 * A pointer to an ExtractionConfig struct that MUST be freed with
 * `kreuzberg_config_free`, or NULL on error (check kreuzberg_last_error).
 *
 * # Safety
 *
 * - `json_config` must be a valid null-terminated C string
 * - The returned pointer must be freed with `kreuzberg_config_free`
 * - Returns NULL if parsing fails (error available via `kreuzberg_last_error`)
 *
 * # Example (C)
 *
 * ```c
 * const char* config_json = "{\"use_cache\": true, \"ocr\": {\"backend\": \"tesseract\"}}";
 * ExtractionConfig* config = kreuzberg_config_from_json(config_json);
 * if (config == NULL) {
 *     printf("Error: %s\n", kreuzberg_last_error());
 *     return 1;
 * }
 *
 * // Use config...
 * // char* result = kreuzberg_extract_file_with_config("doc.pdf", config);
 *
 * kreuzberg_config_free(config);
 * ```
 */
ExtractionConfig *kreuzberg_config_from_json(const char *json_config);

/**
 * Free an ExtractionConfig allocated by kreuzberg_config_from_json or similar.
 *
 * # Safety
 *
 * - `config` must be a pointer previously returned by a config creation function
 * - `config` can be NULL (no-op)
 * - `config` must not be used after this call
 *
 * # Example (C)
 *
 * ```c
 * ExtractionConfig* config = kreuzberg_config_from_json("{...}");
 * if (config != NULL) {
 *     // Use config...
 *     kreuzberg_config_free(config);
 * }
 * ```
 */
void kreuzberg_config_free(ExtractionConfig *config);

/**
 * Validate a JSON config string without parsing it.
 *
 * This function checks if a JSON config string is valid and would parse correctly,
 * without allocating the full ExtractionConfig structure. Useful for validation
 * before committing to parsing.
 *
 * # Arguments
 *
 * * `json_config` - Null-terminated C string containing JSON configuration
 *
 * # Returns
 *
 * - 1 if valid (would parse successfully)
 * - 0 if invalid (check `kreuzberg_last_error` for details)
 *
 * # Safety
 *
 * - `json_config` must be a valid null-terminated C string
 *
 * # Example (C)
 *
 * ```c
 * const char* config_json = "{\"use_cache\": true}";
 * if (kreuzberg_config_is_valid(config_json)) {
 *     ExtractionConfig* config = kreuzberg_config_from_json(config_json);
 *     // Use config...
 *     kreuzberg_config_free(config);
 * } else {
 *     printf("Invalid config: %s\n", kreuzberg_last_error());
 * }
 * ```
 */
int32_t kreuzberg_config_is_valid(const char *json_config);

/**
 * Returns the validation error code (0).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_validation(void);
 * ```
 */
uint32_t kreuzberg_error_code_validation(void);

/**
 * Returns the parsing error code (1).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_parsing(void);
 * ```
 */
uint32_t kreuzberg_error_code_parsing(void);

/**
 * Returns the OCR error code (2).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_ocr(void);
 * ```
 */
uint32_t kreuzberg_error_code_ocr(void);

/**
 * Returns the missing dependency error code (3).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_missing_dependency(void);
 * ```
 */
uint32_t kreuzberg_error_code_missing_dependency(void);

/**
 * Returns the I/O error code (4).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_io(void);
 * ```
 */
uint32_t kreuzberg_error_code_io(void);

/**
 * Returns the plugin error code (5).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_plugin(void);
 * ```
 */
uint32_t kreuzberg_error_code_plugin(void);

/**
 * Returns the unsupported format error code (6).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_unsupported_format(void);
 * ```
 */
uint32_t kreuzberg_error_code_unsupported_format(void);

/**
 * Returns the internal error code (7).
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_internal(void);
 * ```
 */
uint32_t kreuzberg_error_code_internal(void);

/**
 * Returns the total count of valid error codes.
 *
 * Currently 8 error codes (0-7). This helps bindings validate error codes.
 *
 * # C Signature
 *
 * ```c
 * uint32_t kreuzberg_error_code_count(void);
 * ```
 */
uint32_t kreuzberg_error_code_count(void);

/**
 * Returns the name of an error code as a C string.
 *
 * # Arguments
 *
 * - `code`: Numeric error code (0-7)
 *
 * # Returns
 *
 * Pointer to a null-terminated C string with the error name (e.g., "validation", "ocr").
 * Returns a pointer to "unknown" if the code is invalid.
 *
 * The returned pointer is valid for the lifetime of the program and should not be freed.
 *
 * # Examples
 *
 * ```c
 * const char* name = kreuzberg_error_code_name(0);
 * printf("%s\n", name);  // prints: validation
 * ```
 *
 * # C Signature
 *
 * ```c
 * const char* kreuzberg_error_code_name(uint32_t code);
 * ```
 */
const char *kreuzberg_error_code_name(uint32_t code);

/**
 * Returns the description of an error code as a C string.
 *
 * # Arguments
 *
 * - `code`: Numeric error code (0-7)
 *
 * # Returns
 *
 * Pointer to a null-terminated C string with a description (e.g., "Input validation error").
 * Returns a pointer to "Unknown error code" if the code is invalid.
 *
 * The returned pointer is valid for the lifetime of the program and should not be freed.
 *
 * # C Signature
 *
 * ```c
 * const char* kreuzberg_error_code_description(uint32_t code);
 * ```
 */
const char *kreuzberg_error_code_description(uint32_t code);

/**
 * Validates a binarization method string.
 *
 * # Arguments
 *
 * * `method` - C string containing the binarization method (e.g., "otsu", "adaptive", "sauvola")
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # Safety
 *
 * * `method` must be a valid pointer to a null-terminated UTF-8 string
 * * `method` cannot be NULL
 * * The string must be valid for the duration of the call
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_binarization_method(const char* method);
 * ```
 */
int32_t kreuzberg_validate_binarization_method(const char *method);

/**
 * Validates an OCR backend string.
 *
 * # Arguments
 *
 * * `backend` - C string containing the OCR backend (e.g., "tesseract", "easyocr", "paddleocr")
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # Safety
 *
 * * `backend` must be a valid pointer to a null-terminated UTF-8 string
 * * `backend` cannot be NULL
 * * The string must be valid for the duration of the call
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_ocr_backend(const char* backend);
 * ```
 */
int32_t kreuzberg_validate_ocr_backend(const char *backend);

/**
 * Validates a language code (ISO 639-1 or 639-3 format).
 *
 * Accepts both 2-letter codes (e.g., "en", "de") and 3-letter codes (e.g., "eng", "deu").
 *
 * # Arguments
 *
 * * `code` - C string containing the language code
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # Safety
 *
 * * `code` must be a valid pointer to a null-terminated UTF-8 string
 * * `code` cannot be NULL
 * * The string must be valid for the duration of the call
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_language_code(const char* code);
 * ```
 */
int32_t kreuzberg_validate_language_code(const char *code);

/**
 * Validates a token reduction level string.
 *
 * # Arguments
 *
 * * `level` - C string containing the token reduction level (e.g., "off", "light", "moderate")
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # Safety
 *
 * * `level` must be a valid pointer to a null-terminated UTF-8 string
 * * `level` cannot be NULL
 * * The string must be valid for the duration of the call
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_token_reduction_level(const char* level);
 * ```
 */
int32_t kreuzberg_validate_token_reduction_level(const char *level);

/**
 * Validates a tesseract Page Segmentation Mode (PSM) value.
 *
 * # Arguments
 *
 * * `psm` - PSM value (valid range: 0-13)
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_tesseract_psm(int32_t psm);
 * ```
 */
int32_t kreuzberg_validate_tesseract_psm(int32_t psm);

/**
 * Validates a tesseract OCR Engine Mode (OEM) value.
 *
 * # Arguments
 *
 * * `oem` - OEM value (valid range: 0-3)
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_tesseract_oem(int32_t oem);
 * ```
 */
int32_t kreuzberg_validate_tesseract_oem(int32_t oem);

/**
 * Validates a tesseract output format string.
 *
 * # Arguments
 *
 * * `format` - C string containing the output format (e.g., "text", "markdown")
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # Safety
 *
 * * `format` must be a valid pointer to a null-terminated UTF-8 string
 * * `format` cannot be NULL
 * * The string must be valid for the duration of the call
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_output_format(const char* format);
 * ```
 */
int32_t kreuzberg_validate_output_format(const char *format);

/**
 * Validates a confidence threshold value.
 *
 * Confidence thresholds must be between 0.0 and 1.0 inclusive.
 *
 * # Arguments
 *
 * * `confidence` - Confidence threshold value
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_confidence(double confidence);
 * ```
 */
int32_t kreuzberg_validate_confidence(double confidence);

/**
 * Validates a DPI (dots per inch) value.
 *
 * DPI must be a positive integer, typically 72-600.
 *
 * # Arguments
 *
 * * `dpi` - DPI value
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_dpi(int32_t dpi);
 * ```
 */
int32_t kreuzberg_validate_dpi(int32_t dpi);

/**
 * Validates chunking parameters.
 *
 * Checks that `max_chars > 0` and `max_overlap < max_chars`.
 *
 * # Arguments
 *
 * * `max_chars` - Maximum characters per chunk
 * * `max_overlap` - Maximum overlap between chunks
 *
 * # Returns
 *
 * - `1` if valid
 * - `0` if invalid (error message available via `kreuzberg_get_last_error_message()`)
 *
 * # C Signature
 *
 * ```c
 * int32_t kreuzberg_validate_chunking_params(size_t max_chars, size_t max_overlap);
 * ```
 */
int32_t kreuzberg_validate_chunking_params(uintptr_t max_chars, uintptr_t max_overlap);

/**
 * Returns valid binarization methods as a JSON array string.
 *
 * The returned string MUST be freed by the caller using `kreuzberg_free_string()`.
 *
 * # Returns
 *
 * A pointer to a dynamically allocated C string containing a JSON array of valid methods.
 * Returns NULL if memory allocation fails (error message set via `set_last_error()`).
 *
 * # Example
 *
 * The returned JSON string looks like: `["otsu","adaptive","sauvola"]`
 *
 * # C Signature
 *
 * ```c
 * char* kreuzberg_get_valid_binarization_methods(void);
 * ```
 */
char *kreuzberg_get_valid_binarization_methods(void);

/**
 * Returns valid language codes as a JSON array string.
 *
 * The returned string MUST be freed by the caller using `kreuzberg_free_string()`.
 *
 * # Returns
 *
 * A pointer to a dynamically allocated C string containing a JSON array of valid codes.
 * Returns NULL if memory allocation fails (error message set via `set_last_error()`).
 *
 * # C Signature
 *
 * ```c
 * char* kreuzberg_get_valid_language_codes(void);
 * ```
 */
char *kreuzberg_get_valid_language_codes(void);

/**
 * Returns valid OCR backends as a JSON array string.
 *
 * The returned string MUST be freed by the caller using `kreuzberg_free_string()`.
 *
 * # Returns
 *
 * A pointer to a dynamically allocated C string containing a JSON array of valid backends.
 * Returns NULL if memory allocation fails (error message set via `set_last_error()`).
 *
 * # C Signature
 *
 * ```c
 * char* kreuzberg_get_valid_ocr_backends(void);
 * ```
 */
char *kreuzberg_get_valid_ocr_backends(void);

/**
 * Returns valid token reduction levels as a JSON array string.
 *
 * The returned string MUST be freed by the caller using `kreuzberg_free_string()`.
 *
 * # Returns
 *
 * A pointer to a dynamically allocated C string containing a JSON array of valid levels.
 * Returns NULL if memory allocation fails (error message set via `set_last_error()`).
 *
 * # C Signature
 *
 * ```c
 * char* kreuzberg_get_valid_token_reduction_levels(void);
 * ```
 */
char *kreuzberg_get_valid_token_reduction_levels(void);

#endif  /* KREUZBERG_FFI_H */
