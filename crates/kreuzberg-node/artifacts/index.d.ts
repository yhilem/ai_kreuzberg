/* auto-generated by NAPI-RS */
/* eslint-disable */
/**
 * Batch extract from multiple byte arrays (asynchronous).
 *
 * Asynchronously processes multiple in-memory buffers in parallel. Non-blocking
 * alternative to `batchExtractBytesSync`.
 *
 * # Parameters
 *
 * * `data_list` - Array of buffers to extract
 * * `mime_types` - Array of MIME types (must match data_list length)
 * * `config` - Optional extraction configuration
 *
 * # Returns
 *
 * Promise resolving to array of `ExtractionResult`.
 *
 * # Example
 *
 * ```typescript
 * import { batchExtractBytes } from '@kreuzberg/node';
 *
 * const responses = await Promise.all([
 *   fetch('https://example.com/doc1.pdf'),
 *   fetch('https://example.com/doc2.pdf')
 * ]);
 * const buffers = await Promise.all(
 *   responses.map(r => r.arrayBuffer().then(b => Buffer.from(b)))
 * );
 * const results = await batchExtractBytes(
 *   buffers,
 *   ['application/pdf', 'application/pdf'],
 *   null
 * );
 * ```
 */
export declare function batchExtractBytes(
	dataList: Array<Buffer>,
	mimeTypes: Array<string>,
	config?: JsExtractionConfig | undefined | null,
): Promise<Array<JsExtractionResult>>;

/**
 * Batch extract from multiple byte arrays (synchronous).
 *
 * Synchronously processes multiple in-memory buffers in parallel. Requires
 * corresponding MIME types for each buffer.
 *
 * # Parameters
 *
 * * `data_list` - Array of buffers to extract
 * * `mime_types` - Array of MIME types (must match data_list length)
 * * `config` - Optional extraction configuration
 *
 * # Returns
 *
 * Array of `ExtractionResult` in the same order as inputs.
 *
 * # Errors
 *
 * Throws if data_list and mime_types lengths don't match.
 *
 * # Example
 *
 * ```typescript
 * import { batchExtractBytesSync } from '@kreuzberg/node';
 *
 * const buffers = [buffer1, buffer2, buffer3];
 * const mimeTypes = ['application/pdf', 'image/png', 'text/plain'];
 * const results = batchExtractBytesSync(buffers, mimeTypes, null);
 * ```
 */
export declare function batchExtractBytesSync(
	dataList: Array<Buffer>,
	mimeTypes: Array<string>,
	config?: JsExtractionConfig | undefined | null,
): Array<JsExtractionResult>;

/**
 * Batch extract from multiple files (asynchronous).
 *
 * Asynchronously processes multiple files in parallel. Non-blocking alternative
 * to `batchExtractFilesSync` with same performance benefits.
 *
 * # Parameters
 *
 * * `paths` - Array of file paths to extract
 * * `config` - Optional extraction configuration (applied to all files)
 *
 * # Returns
 *
 * Promise resolving to array of `ExtractionResult`.
 *
 * # Example
 *
 * ```typescript
 * import { batchExtractFiles } from '@kreuzberg/node';
 *
 * const files = ['report1.pdf', 'report2.pdf', 'report3.pdf'];
 * const results = await batchExtractFiles(files, null);
 * console.log(`Processed ${results.length} files`);
 * ```
 */
export declare function batchExtractFiles(
	paths: Array<string>,
	config?: JsExtractionConfig | undefined | null,
): Promise<Array<JsExtractionResult>>;

/**
 * Batch extract from multiple files (synchronous).
 *
 * Synchronously processes multiple files in parallel using Rayon. Significantly
 * faster than sequential processing for large batches.
 *
 * # Parameters
 *
 * * `paths` - Array of file paths to extract
 * * `config` - Optional extraction configuration (applied to all files)
 *
 * # Returns
 *
 * Array of `ExtractionResult` in the same order as input paths.
 *
 * # Example
 *
 * ```typescript
 * import { batchExtractFilesSync } from '@kreuzberg/node';
 *
 * const files = ['doc1.pdf', 'doc2.docx', 'doc3.txt'];
 * const results = batchExtractFilesSync(files, null);
 * results.forEach((result, i) => {
 *   console.log(`File ${files[i]}: ${result.content.substring(0, 100)}...`);
 * });
 * ```
 */
export declare function batchExtractFilesSync(
	paths: Array<string>,
	config?: JsExtractionConfig | undefined | null,
): Array<JsExtractionResult>;

/**
 * Clear all registered document extractors.
 *
 * Removes all document extractors from the registry, including built-in extractors.
 * Use with caution as this will make document extraction unavailable until
 * extractors are re-registered.
 *
 * # Example
 *
 * ```typescript
 * import { clearDocumentExtractors } from 'kreuzberg';
 *
 * clearDocumentExtractors();
 * ```
 */
export declare function clearDocumentExtractors(): void;

/**
 * Clear all registered OCR backends.
 *
 * Removes all OCR backends from the registry, including built-in backends.
 * Use with caution as this will make OCR functionality unavailable until
 * backends are re-registered.
 *
 * # Example
 *
 * ```typescript
 * import { clearOcrBackends } from 'kreuzberg';
 *
 * clearOcrBackends();
 * ```
 */
export declare function clearOcrBackends(): void;

/** Clear all registered postprocessors */
export declare function clearPostProcessors(): void;

/** Clear all registered validators */
export declare function clearValidators(): void;

/**
 * Detect MIME type from raw bytes.
 *
 * Uses content inspection (magic bytes) to determine MIME type.
 * This is more accurate than extension-based detection but requires
 * reading the file content.
 *
 * # Parameters
 *
 * * `bytes` - Raw file content as Buffer
 *
 * # Returns
 *
 * The detected MIME type string.
 *
 * # Errors
 *
 * Throws an error if MIME type cannot be determined from content.
 *
 * # Example
 *
 * ```typescript
 * import { detectMimeType } from 'kreuzberg';
 * import * as fs from 'fs';
 *
 * // Read file content
 * const content = fs.readFileSync('document.pdf');
 *
 * // Detect MIME type from bytes
 * const mimeType = detectMimeType(content);
 * console.log(mimeType); // 'application/pdf'
 * ```
 */
export declare function detectMimeTypeFromBytes(bytes: Buffer): string;

/**
 * Detect MIME type from a file path.
 *
 * Uses file extension to determine MIME type. Falls back to `mime_guess` crate
 * if extension-based detection fails.
 *
 * # Parameters
 *
 * * `path` - Path to the file (string)
 * * `check_exists` - Whether to verify file existence (default: true)
 *
 * # Returns
 *
 * The detected MIME type string.
 *
 * # Errors
 *
 * Throws an error if:
 * - File doesn't exist (when check_exists is true)
 * - MIME type cannot be determined from path/extension
 * - Extension is unknown
 *
 * # Example
 *
 * ```typescript
 * import { detectMimeTypeFromPath } from 'kreuzberg';
 *
 * // Detect from existing file
 * const mimeType = detectMimeTypeFromPath('document.pdf');
 * console.log(mimeType); // 'application/pdf'
 *
 * const mimeType2 = detectMimeTypeFromPath('document.docx');
 * console.log(mimeType2); // 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
 * ```
 */
export declare function detectMimeTypeFromPath(path: string, checkExists?: boolean | undefined | null): string;

/**
 * Discover and load extraction configuration from current or parent directories.
 *
 * Searches for a `kreuzberg.toml` file starting from the current working directory
 * and traversing up the directory tree. Returns the first configuration file found.
 *
 * # Returns
 *
 * `JsExtractionConfig` object if a configuration file is found, or `null` if no
 * configuration file exists in the current or parent directories.
 *
 * # Example
 *
 * ```typescript
 * import { ExtractionConfig } from 'kreuzberg';
 *
 * // Try to find config in current or parent directories
 * const config = ExtractionConfig.discover();
 * if (config) {
 *   console.log('Found configuration');
 *   // Use config for extraction
 * } else {
 *   console.log('No configuration file found, using defaults');
 * }
 * ```
 */
export declare function discoverExtractionConfig(): JsExtractionConfig | null;

/**
 * Embedding preset configuration for TypeScript bindings.
 *
 * Contains all settings for a specific embedding model preset.
 */
export interface EmbeddingPreset {
	/** Name of the preset (e.g., "fast", "balanced", "quality", "multilingual") */
	name: string;
	/** Recommended chunk size in characters */
	chunkSize: number;
	/** Recommended overlap in characters */
	overlap: number;
	/** Model identifier (e.g., "AllMiniLML6V2Q", "BGEBaseENV15") */
	modelName: string;
	/** Embedding vector dimensions */
	dimensions: number;
	/** Human-readable description of the preset */
	description: string;
}

/**
 * Extract content from bytes (asynchronous).
 *
 * Asynchronously extracts content from a byte buffer. Non-blocking alternative
 * to `extractBytesSync` for processing in-memory data.
 *
 * # Parameters
 *
 * * `data` - Buffer containing the document bytes
 * * `mime_type` - MIME type of the data
 * * `config` - Optional extraction configuration
 *
 * # Returns
 *
 * Promise resolving to `ExtractionResult`.
 *
 * # Example
 *
 * ```typescript
 * import { extractBytes } from '@kreuzberg/node';
 *
 * const response = await fetch('https://example.com/document.pdf');
 * const buffer = Buffer.from(await response.arrayBuffer());
 * const result = await extractBytes(buffer, 'application/pdf', null);
 * ```
 */
export declare function extractBytes(
	data: Buffer,
	mimeType: string,
	config?: JsExtractionConfig | undefined | null,
): Promise<JsExtractionResult>;

/**
 * Extract content from bytes (synchronous).
 *
 * Synchronously extracts content from a byte buffer without requiring a file path.
 * Useful for processing in-memory data, network streams, or database BLOBs.
 *
 * # Parameters
 *
 * * `data` - Buffer containing the document bytes
 * * `mime_type` - MIME type of the data (e.g., "application/pdf", "image/png")
 * * `config` - Optional extraction configuration
 *
 * # Returns
 *
 * `ExtractionResult` with extracted content and metadata.
 *
 * # Errors
 *
 * Throws an error if data is malformed or MIME type is unsupported.
 *
 * # Example
 *
 * ```typescript
 * import { extractBytesSync } from '@kreuzberg/node';
 * import fs from 'fs';
 *
 * const buffer = fs.readFileSync('document.pdf');
 * const result = extractBytesSync(buffer, 'application/pdf', null);
 * console.log(result.content);
 * ```
 */
export declare function extractBytesSync(
	data: Buffer,
	mimeType: string,
	config?: JsExtractionConfig | undefined | null,
): JsExtractionResult;

/**
 * Extract content from a file (asynchronous).
 *
 * Asynchronously extracts text, tables, images, and metadata from a document file.
 * Non-blocking alternative to `extractFileSync` for use in async/await contexts.
 *
 * # Parameters
 *
 * * `file_path` - Path to the file to extract (absolute or relative)
 * * `mime_type` - Optional MIME type hint (auto-detected if omitted)
 * * `config` - Optional extraction configuration (OCR, chunking, etc.)
 *
 * # Returns
 *
 * Promise resolving to `ExtractionResult` with extracted content and metadata.
 *
 * # Errors
 *
 * Rejects if file processing fails (see `extractFileSync` for error conditions).
 *
 * # Example
 *
 * ```typescript
 * import { extractFile } from '@kreuzberg/node';
 *
 * // Async/await usage
 * const result = await extractFile('document.pdf', null, null);
 * console.log(result.content);
 *
 * // Promise usage
 * extractFile('report.docx', null, null)
 *   .then(result => console.log(result.content))
 *   .catch(err => console.error(err));
 * ```
 */
export declare function extractFile(
	filePath: string,
	mimeType?: string | undefined | null,
	config?: JsExtractionConfig | undefined | null,
): Promise<JsExtractionResult>;

/**
 * Extract content from a file (synchronous).
 *
 * Synchronously extracts text, tables, images, and metadata from a document file.
 * Supports 118+ file formats including PDFs, Office documents, images, and more.
 *
 * # Parameters
 *
 * * `file_path` - Path to the file to extract (absolute or relative)
 * * `mime_type` - Optional MIME type hint (auto-detected if omitted)
 * * `config` - Optional extraction configuration (OCR, chunking, etc.)
 *
 * # Returns
 *
 * `ExtractionResult` containing:
 * - `content`: Extracted text content
 * - `mimeType`: Detected MIME type
 * - `metadata`: File metadata (author, title, etc.)
 * - `tables`: Extracted tables (if any)
 * - `images`: Extracted images (if configured)
 * - `chunks`: Text chunks (if chunking enabled)
 * - `detectedLanguages`: Detected languages (if enabled)
 *
 * # Errors
 *
 * Throws an error if:
 * - File does not exist or is not accessible
 * - File format is unsupported
 * - File is corrupted or malformed
 * - OCR processing fails (if enabled)
 *
 * # Example
 *
 * ```typescript
 * import { extractFileSync, ExtractionConfig } from '@kreuzberg/node';
 *
 * // Basic extraction
 * const result = extractFileSync('document.pdf', null, null);
 * console.log(result.content);
 *
 * // With MIME type hint
 * const result2 = extractFileSync('file.bin', 'application/pdf', null);
 *
 * // With OCR enabled
 * const config: ExtractionConfig = {
 *   ocr: {
 *     backend: 'tesseract',
 *     language: 'eng',
 *   }
 * };
 * const result3 = extractFileSync('scanned.pdf', null, config);
 * ```
 */
export declare function extractFileSync(
	filePath: string,
	mimeType?: string | undefined | null,
	config?: JsExtractionConfig | undefined | null,
): JsExtractionResult;

/**
 * Get a specific embedding preset by name.
 *
 * Returns a preset configuration object, or null if the preset name is not found.
 *
 * # Arguments
 *
 * * `name` - The preset name (case-sensitive)
 *
 * # Returns
 *
 * An `EmbeddingPreset` object with the following properties:
 * - `name`: string - Preset name
 * - `chunkSize`: number - Recommended chunk size in characters
 * - `overlap`: number - Recommended overlap in characters
 * - `modelName`: string - Model identifier
 * - `dimensions`: number - Embedding vector dimensions
 * - `description`: string - Human-readable description
 *
 * Returns `null` if preset name is not found.
 *
 * # Example
 *
 * ```typescript
 * import { getEmbeddingPreset } from 'kreuzberg';
 *
 * const preset = getEmbeddingPreset('balanced');
 * if (preset) {
 *   console.log(`Model: ${preset.modelName}, Dims: ${preset.dimensions}`);
 *   // Model: BGEBaseENV15, Dims: 768
 * }
 * ```
 */
export declare function getEmbeddingPreset(name: string): EmbeddingPreset | null;

/**
 * Get file extensions for a given MIME type.
 *
 * Returns an array of file extensions commonly associated with the specified
 * MIME type. For example, 'application/pdf' returns ['pdf'].
 *
 * # Parameters
 *
 * * `mime_type` - The MIME type to look up (e.g., 'application/pdf', 'image/jpeg')
 *
 * # Returns
 *
 * Array of file extensions (without leading dots).
 *
 * # Errors
 *
 * Throws an error if the MIME type is not recognized or supported.
 *
 * # Example
 *
 * ```typescript
 * import { getExtensionsForMime } from 'kreuzberg';
 *
 * // Get extensions for PDF
 * const pdfExts = getExtensionsForMime('application/pdf');
 * console.log(pdfExts); // ['pdf']
 *
 * // Get extensions for JPEG
 * const jpegExts = getExtensionsForMime('image/jpeg');
 * console.log(jpegExts); // ['jpg', 'jpeg']
 * ```
 */
export declare function getExtensionsForMime(mimeType: string): Array<string>;

/**
 * Get the error code for the last FFI error.
 *
 * Returns the FFI error code as an integer. Error codes are:
 * - 0: Success (no error)
 * - 1: GenericError
 * - 2: Panic
 * - 3: InvalidArgument
 * - 4: IoError
 * - 5: ParsingError
 * - 6: OcrError
 * - 7: MissingDependency
 *
 * This is useful for programmatic error handling and distinguishing
 * between different types of failures in native code.
 *
 * # Returns
 *
 * The integer error code.
 *
 * # Example
 *
 * ```typescript
 * import { extractFile, getLastErrorCode, ErrorCode } from '@kreuzberg/node';
 *
 * try {
 *   const result = await extractFile('document.pdf');
 * } catch (error) {
 *   const code = getLastErrorCode();
 *   if (code === ErrorCode.Panic) {
 *     console.error('Native code panic detected');
 *   }
 * }
 * ```
 */
export declare function getLastErrorCode(): number;

/**
 * Get panic context information if the last error was a panic.
 *
 * Returns detailed information about a panic in native code, or null
 * if the last error was not a panic.
 *
 * # Returns
 *
 * A `PanicContext` object with:
 * - `file`: string - Source file where panic occurred
 * - `line`: number - Line number
 * - `function`: string - Function name
 * - `message`: string - Panic message
 * - `timestamp_secs`: number - Unix timestamp (seconds since epoch)
 *
 * Returns `null` if no panic context is available.
 *
 * # Example
 *
 * ```typescript
 * import { extractFile, getLastPanicContext } from '@kreuzberg/node';
 *
 * try {
 *   const result = await extractFile('document.pdf');
 * } catch (error) {
 *   const context = getLastPanicContext();
 *   if (context) {
 *     console.error(`Panic at ${context.file}:${context.line}`);
 *     console.error(`In function: ${context.function}`);
 *     console.error(`Message: ${context.message}`);
 *   }
 * }
 * ```
 */
export declare function getLastPanicContext(): any | null;

export interface JsChunk {
	content: string;
	embedding?: number[] | undefined;
	metadata: JsChunkMetadata;
}

export interface JsChunkingConfig {
	maxChars?: number;
	maxOverlap?: number;
	/** Optional embedding configuration for generating embeddings */
	embedding?: JsEmbeddingConfig;
	/** Optional preset name for chunking parameters */
	preset?: string;
}

export interface JsChunkMetadata {
	byteStart: number;
	byteEnd: number;
	tokenCount?: number;
	chunkIndex: number;
	totalChunks: number;
	firstPage?: number;
	lastPage?: number;
}

/** Embedding generation configuration for Node.js bindings. */
export interface JsEmbeddingConfig {
	/** Embedding model configuration */
	model?: JsEmbeddingModelType;
	/** Whether to normalize embeddings (L2 normalization) */
	normalize?: boolean;
	/** Batch size for embedding generation */
	batchSize?: number;
	/** Whether to show download progress for models */
	showDownloadProgress?: boolean;
	/** Custom cache directory for model storage */
	cacheDir?: string;
}

/**
 * Embedding model type configuration for Node.js bindings.
 *
 * This struct represents different embedding model sources:
 * - `preset`: Use a named preset (e.g., "balanced", "fast", "quality", "multilingual")
 * - `fastembed`: Use a FastEmbed model with custom dimensions
 * - `custom`: Use a custom ONNX model
 */
export interface JsEmbeddingModelType {
	/** Type of model: "preset", "fastembed", or "custom" */
	modelType: string;
	/** For preset: preset name; for fastembed/custom: model ID */
	value: string;
	/** Number of dimensions (only for fastembed/custom) */
	dimensions?: number;
}

export interface JsExtractedImage {
	data: Buffer;
	format: string;
	imageIndex: number;
	pageNumber?: number;
	width?: number;
	height?: number;
	colorspace?: string;
	bitsPerComponent?: number;
	isMask: boolean;
	description?: string;
	ocrResult?: JsExtractionResult | undefined;
}

export interface JsExtractionConfig {
	useCache?: boolean;
	enableQualityProcessing?: boolean;
	ocr?: JsOcrConfig;
	forceOcr?: boolean;
	chunking?: JsChunkingConfig;
	images?: JsImageExtractionConfig;
	pdfOptions?: JsPdfConfig;
	tokenReduction?: JsTokenReductionConfig;
	languageDetection?: JsLanguageDetectionConfig;
	postprocessor?: JsPostProcessorConfig;
	keywords?: JsKeywordConfig;
	htmlOptions?: JsHtmlOptions;
	maxConcurrentExtractions?: number;
	pages?: JsPageConfig;
}

export interface JsExtractionResult {
	content: string;
	mimeType: string;
	metadata: Metadata;
	tables: Array<JsTable>;
	detectedLanguages?: Array<string>;
	chunks?: Array<JsChunk>;
	images?: Array<JsExtractedImage>;
}

export interface JsHtmlOptions {
	headingStyle?: string;
	listIndentType?: string;
	listIndentWidth?: number;
	bullets?: string;
	strongEmSymbol?: string;
	escapeAsterisks?: boolean;
	escapeUnderscores?: boolean;
	escapeMisc?: boolean;
	escapeAscii?: boolean;
	codeLanguage?: string;
	autolinks?: boolean;
	defaultTitle?: boolean;
	brInTables?: boolean;
	hocrSpatialTables?: boolean;
	highlightStyle?: string;
	extractMetadata?: boolean;
	whitespaceMode?: string;
	stripNewlines?: boolean;
	wrap?: boolean;
	wrapWidth?: number;
	convertAsInline?: boolean;
	subSymbol?: string;
	supSymbol?: string;
	newlineStyle?: string;
	codeBlockStyle?: string;
	keepInlineImagesIn?: Array<string>;
	encoding?: string;
	debug?: boolean;
	stripTags?: Array<string>;
	preserveTags?: Array<string>;
	preprocessing?: JsHtmlPreprocessingOptions;
}

export interface JsHtmlPreprocessingOptions {
	enabled?: boolean;
	preset?: string;
	removeNavigation?: boolean;
	removeForms?: boolean;
}

export interface JsImageExtractionConfig {
	extractImages?: boolean;
	targetDpi?: number;
	maxImageDimension?: number;
	autoAdjustDpi?: boolean;
	minDpi?: number;
	maxDpi?: number;
}

export interface JsKeywordConfig {
	algorithm?: string;
	maxKeywords?: number;
	minScore?: number;
	ngramRange?: [number, number] | undefined;
	language?: string;
	yakeParams?: JsYakeParams;
	rakeParams?: JsRakeParams;
}

export interface JsLanguageDetectionConfig {
	enabled?: boolean;
	minConfidence?: number;
	detectMultiple?: boolean;
}

export interface JsOcrConfig {
	backend: string;
	language?: string;
	tesseractConfig?: JsTesseractConfig;
}

export interface JsPageConfig {
	extractPages?: boolean;
	insertPageMarkers?: boolean;
	markerFormat?: string;
}

export interface JsPdfConfig {
	extractImages?: boolean;
	passwords?: Array<string>;
	extractMetadata?: boolean;
}

export interface JsPostProcessorConfig {
	enabled?: boolean;
	enabledProcessors?: Array<string>;
	disabledProcessors?: Array<string>;
}

export interface JsRakeParams {
	minWordLength?: number;
	maxWordsPerPhrase?: number;
}

export interface JsTable {
	cells: Array<Array<string>>;
	markdown: string;
	pageNumber: number;
}

export interface JsTesseractConfig {
	psm?: number;
	enableTableDetection?: boolean;
	tesseditCharWhitelist?: string;
}

export interface JsTokenReductionConfig {
	mode?: string;
	preserveImportantWords?: boolean;
}

export interface JsYakeParams {
	windowSize?: number;
}

/**
 * List all registered document extractors.
 *
 * Returns an array of names of all currently registered document extractors,
 * including built-in extractors for PDF, Office documents, images, etc.
 *
 * # Returns
 *
 * Array of document extractor names.
 *
 * # Example
 *
 * ```typescript
 * import { listDocumentExtractors } from 'kreuzberg';
 *
 * const extractors = listDocumentExtractors();
 * console.log(extractors); // ['PDFExtractor', 'ImageExtractor', ...]
 * ```
 */
export declare function listDocumentExtractors(): Array<string>;

/**
 * List all available embedding preset names.
 *
 * Returns an array of preset names that can be used with `getEmbeddingPreset`.
 *
 * # Returns
 *
 * Array of 4 preset names: ["fast", "balanced", "quality", "multilingual"]
 *
 * # Example
 *
 * ```typescript
 * import { listEmbeddingPresets } from 'kreuzberg';
 *
 * const presets = listEmbeddingPresets();
 * console.log(presets); // ['fast', 'balanced', 'quality', 'multilingual']
 * ```
 */
export declare function listEmbeddingPresets(): Array<string>;

/**
 * List all registered OCR backends.
 *
 * Returns an array of names of all currently registered OCR backends,
 * including built-in backends like "tesseract".
 *
 * # Returns
 *
 * Array of OCR backend names.
 *
 * # Example
 *
 * ```typescript
 * import { listOcrBackends } from 'kreuzberg';
 *
 * const backends = listOcrBackends();
 * console.log(backends); // ['tesseract', 'my-custom-backend', ...]
 * ```
 */
export declare function listOcrBackends(): Array<string>;

/** List all registered post-processors */
export declare function listPostProcessors(): Array<string>;

/** List all registered validators */
export declare function listValidators(): Array<string>;

/**
 * Load extraction configuration from a file.
 *
 * Automatically detects the file format based on extension:
 * - `.toml` - TOML format
 * - `.yaml` - YAML format
 * - `.json` - JSON format
 *
 * # Parameters
 *
 * * `file_path` - Path to the configuration file (absolute or relative)
 *
 * # Returns
 *
 * `JsExtractionConfig` object with loaded configuration.
 *
 * # Errors
 *
 * Throws an error if:
 * - File does not exist or is not accessible
 * - File content is not valid TOML/YAML/JSON
 * - Configuration structure is invalid
 *
 * # Example
 *
 * ```typescript
 * import { loadExtractionConfigFromFile } from 'kreuzberg';
 *
 * // Load from TOML file
 * const config = loadExtractionConfigFromFile('kreuzberg.toml');
 *
 * // Load from YAML file
 * const config2 = loadExtractionConfigFromFile('./config.yaml');
 *
 * // Use with extraction
 * const result = await extractFile('document.pdf', null, config);
 * ```
 */
export declare function loadExtractionConfigFromFile(filePath: string): JsExtractionConfig;

/**
 * Register a custom OCR backend
 *
 * Registers a JavaScript OCR backend that can process images and extract text.
 *
 * # Arguments
 *
 * * `backend` - JavaScript object with the following interface:
 *   - `name(): string` - Unique backend name
 *   - `supportedLanguages(): string[]` - Array of supported ISO 639-2/3 language codes
 *   - `processImage(imageBytes: string, language: string): Promise<result>` - Process image and return extraction result
 *
 * # Implementation Notes
 *
 * Due to NAPI ThreadsafeFunction limitations, the processImage function receives:
 * - `imageBytes` as a Base64 string (first argument)
 * - `language` as string (second argument)
 *
 * And must return a Promise resolving to a JSON-serializable object with:
 * ```typescript
 * {
 *   content: string,
 *   mime_type: string,  // default: "text/plain"
 *   metadata: object,   // default: {}
 *   tables: array       // default: []
 * }
 * ```
 *
 * # Example
 *
 * ```typescript
 * import { registerOcrBackend } from '@kreuzberg/node';
 *
 * registerOcrBackend({
 *   name: () => "my-ocr",
 *   supportedLanguages: () => ["eng", "deu", "fra"],
 *   processImage: async (imageBytes, language) => {
 *     const buffer = Buffer.from(imageBytes, "base64");
 *     const text = await myOcrLibrary.process(buffer, language);
 *     return {
 *       content: text,
 *       mime_type: "text/plain",
 *       metadata: { confidence: 0.95 },
 *       tables: []
 *     };
 *   }
 * });
 * ```
 */
export declare function registerOcrBackend(backend: object): void;

/**
 * Register a custom postprocessor
 *
 * Registers a JavaScript PostProcessor that will be called after extraction.
 *
 * # Arguments
 *
 * * `processor` - JavaScript object with the following interface:
 *   - `name(): string` - Unique processor name
 *   - `process(...args): string` - Process function that receives JSON string as args\[0\]
 *   - `processingStage(): "early" | "middle" | "late"` - Optional processing stage
 *
 * # Implementation Notes
 *
 * Due to NAPI ThreadsafeFunction limitations, the process function receives the extraction
 * result as a JSON string in args\[0\] and must return a JSON string. Use the TypeScript
 * wrapper functions for a cleaner API.
 *
 * # Example
 *
 * ```typescript
 * import { registerPostProcessor } from '@kreuzberg/node';
 *
 * registerPostProcessor({
 *   name: () => "word-counter",
 *   processingStage: () => "middle",
 *   process: (...args) => {
 *     const result = JSON.parse(args[0]);
 *     const wordCount = result.content.split(/\s+/).length;
 *     result.metadata.word_count = wordCount;
 *     return JSON.stringify(result);
 *   }
 * });
 * ```
 */
export declare function registerPostProcessor(processor: object): void;

/**
 * Register a custom validator
 *
 * Registers a JavaScript Validator that will be called after extraction.
 *
 * # Arguments
 *
 * * `validator` - JavaScript object with the following interface:
 *   - `name(): string` - Unique validator name
 *   - `validate(...args): Promise<string>` - Validate function that receives JSON string as args\[0\]
 *   - `priority(): number` - Optional priority (defaults to 50, higher runs first)
 *
 * # Implementation Notes
 *
 * Due to NAPI ThreadsafeFunction limitations, the validate function receives the extraction
 * result as a JSON string in args\[0\]. On success, return an empty string. On validation
 * failure, throw an error (the Promise should reject). Use the TypeScript wrapper functions
 * for a cleaner API.
 *
 * # Example
 *
 * ```typescript
 * import { registerValidator } from '@kreuzberg/node';
 *
 * registerValidator({
 *   name: () => "min-length",
 *   priority: () => 100,
 *   validate: async (...args) => {
 *     const result = JSON.parse(args[0]);
 *     if (result.content.length < 100) {
 *       throw new Error("ValidationError: Content too short");
 *     }
 *     return ""; // Success - return empty string
 *   }
 * });
 * ```
 */
export declare function registerValidator(validator: object): void;

/**
 * Unregister a document extractor by name.
 *
 * Removes the specified document extractor from the registry. If the extractor
 * doesn't exist, this operation is a no-op (does not throw an error).
 *
 * # Parameters
 *
 * * `name` - Name of the document extractor to unregister
 *
 * # Example
 *
 * ```typescript
 * import { unregisterDocumentExtractor } from 'kreuzberg';
 *
 * // Unregister a custom extractor
 * unregisterDocumentExtractor('MyCustomExtractor');
 * ```
 */
export declare function unregisterDocumentExtractor(name: string): void;

/**
 * Unregister an OCR backend by name.
 *
 * Removes the specified OCR backend from the registry. If the backend doesn't exist,
 * this operation is a no-op (does not throw an error).
 *
 * # Parameters
 *
 * * `name` - Name of the OCR backend to unregister
 *
 * # Example
 *
 * ```typescript
 * import { unregisterOcrBackend } from 'kreuzberg';
 *
 * // Unregister a custom backend
 * unregisterOcrBackend('my-custom-ocr');
 * ```
 */
export declare function unregisterOcrBackend(name: string): void;

/** Unregister a postprocessor by name */
export declare function unregisterPostProcessor(name: string): void;

/** Unregister a validator by name */
export declare function unregisterValidator(name: string): void;

/**
 * Validate that a MIME type is supported by Kreuzberg.
 *
 * Checks if a MIME type is in the list of supported formats. Note that any
 * `image/*` MIME type is automatically considered valid.
 *
 * # Parameters
 *
 * * `mime_type` - The MIME type to validate (string)
 *
 * # Returns
 *
 * The validated MIME type (may be normalized).
 *
 * # Errors
 *
 * Throws an error if the MIME type is not supported.
 *
 * # Example
 *
 * ```typescript
 * import { validateMimeType } from 'kreuzberg';
 *
 * // Validate supported type
 * const validated = validateMimeType('application/pdf');
 * console.log(validated); // 'application/pdf'
 *
 * // Validate custom image type
 * const validated2 = validateMimeType('image/custom-format');
 * console.log(validated2); // 'image/custom-format' (any image/* is valid)
 *
 * // Validate unsupported type (throws error)
 * try {
 *   validateMimeType('video/mp4');
 * } catch (err) {
 *   console.error(err); // Error: Unsupported format: video/mp4
 * }
 * ```
 */
export declare function validateMimeType(mimeType: string): string;
