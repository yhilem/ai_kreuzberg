// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Nodes;
using Kreuzberg;
using Xunit;
using Xunit.Sdk;

namespace Kreuzberg.E2E;

public static class TestHelpers
{
    private static readonly string WorkspaceRoot = ResolveWorkspaceRoot();
    private static readonly string TestDocuments = Path.Combine(WorkspaceRoot, "test_documents");

    static TestHelpers()
    {
        EnsureNativeLibraryLoaded();
    }

    private static string ResolveWorkspaceRoot()
    {
        // Use assembly location instead of unpredictable cwd
        var assemblyPath = System.Reflection.Assembly.GetExecutingAssembly().Location;
        var assemblyDir = Path.GetDirectoryName(assemblyPath)
            ?? throw new InvalidOperationException("Cannot determine assembly directory");

        // Walk up the directory tree looking for Cargo.toml (workspace root marker)
        var current = new DirectoryInfo(assemblyDir);
        while (current is not null && current.Parent is not null)
        {
            var cargoToml = Path.Combine(current.FullName, "Cargo.toml");
            if (File.Exists(cargoToml))
                return current.FullName;

            current = current.Parent;
        }

        throw new InvalidOperationException(
            $"Cannot locate workspace root from assembly path: {assemblyPath}");
    }

    private static void EnsureNativeLibraryLoaded()
    {
        var candidates = new[]
        {
            Path.Combine(WorkspaceRoot, "target", "release", LibraryFileName()),
            Path.Combine(WorkspaceRoot, "target", "debug", LibraryFileName()),
        };

        foreach (var candidate in candidates)
        {
            if (File.Exists(candidate))
            {
                NativeLibrary.Load(candidate);
                return;
            }
        }

        throw new InvalidOperationException($"Native library not found. Expected at: {string.Join(", ", candidates)}");
    }

    private static string LibraryFileName()
    {
        if (OperatingSystem.IsWindows())
        {
            return "kreuzberg_ffi.dll";
        }
        if (OperatingSystem.IsMacOS())
        {
            return "libkreuzberg_ffi.dylib";
        }
        return "libkreuzberg_ffi.so";
    }

    public static string EnsureDocument(string relative, bool skipIfMissing)
    {
        var path = Path.Combine(TestDocuments, relative.Replace('/', Path.DirectorySeparatorChar));
        if (!File.Exists(path))
        {
            if (skipIfMissing)
            {
                throw new Xunit.SkipException($"Missing document {path}");
            }
            throw new FileNotFoundException($"Document unavailable: {path}");
        }
        return path;
    }

    public static ExtractionConfig? BuildConfig(string? configJson)
    {
        if (string.IsNullOrWhiteSpace(configJson))
        {
            return null;
        }
        return Serialization.ParseConfig(configJson!);
    }

    public static ExtractionResult RunExtraction(string relativePath, string? configJson)
    {
        var documentPath = EnsureDocument(relativePath, true);
        var config = BuildConfig(configJson);
        return KreuzbergClient.ExtractFileSync(documentPath, config);
    }

    public static void AssertExpectedMime(ExtractionResult result, IEnumerable<string> expected)
    {
        var tokens = expected.ToArray();
        if (tokens.Length == 0)
        {
            return;
        }
        foreach (var token in tokens)
        {
            if (result.MimeType.Contains(token, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }
        }
        throw new XunitException($"Expected MIME to include one of [{string.Join(", ", tokens)}], got {result.MimeType}");
    }

    public static void AssertMinContentLength(ExtractionResult result, int minimum)
    {
        if (result.Content.Length < minimum)
        {
            throw new XunitException($"Expected content length >= {minimum}, got {result.Content.Length}");
        }
    }

    public static void AssertMaxContentLength(ExtractionResult result, int maximum)
    {
        if (result.Content.Length > maximum)
        {
            throw new XunitException($"Expected content length <= {maximum}, got {result.Content.Length}");
        }
    }

    public static void AssertContentContainsAny(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        foreach (var snippet in list)
        {
            if (lowered.Contains(snippet.ToLowerInvariant()))
            {
                return;
            }
        }
        throw new XunitException($"Expected content to contain any of [{string.Join(", ", list)}]");
    }

    public static void AssertContentContainsAll(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        var missing = list.Where(snippet => !lowered.Contains(snippet.ToLowerInvariant())).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected content to contain all snippets, missing: [{string.Join(", ", missing)}]");
        }
    }

    public static void AssertTableCount(ExtractionResult result, int? min, int? max)
    {
        var count = result.Tables?.Count ?? 0;
        if (min.HasValue && count < min.Value)
        {
            throw new XunitException($"Expected at least {min.Value} tables, got {count}");
        }
        if (max.HasValue && count > max.Value)
        {
            throw new XunitException($"Expected at most {max.Value} tables, got {count}");
        }
    }

    public static void AssertDetectedLanguages(ExtractionResult result, IEnumerable<string> expected, double? minConfidence)
    {
        var expectedList = expected.ToArray();
        if (expectedList.Length == 0)
        {
            return;
        }
        var langs = result.DetectedLanguages ?? new List<string>();
        if (langs.Count == 0)
        {
            throw new XunitException($"Expected detected languages {string.Join(", ", expectedList)} but field is empty");
        }

        var missing = expectedList.Where(lang => !langs.Any(candidate => string.Equals(candidate, lang, StringComparison.OrdinalIgnoreCase))).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected languages {string.Join(", ", expectedList)}, missing {string.Join(", ", missing)}");
        }

        if (minConfidence.HasValue)
        {
            var metadataNode = MetadataToJson(result.Metadata);
            var confidence = LookupMetadata(metadataNode, "confidence");
            if (confidence is JsonValue value && value.TryGetValue<double>(out var dbl) && dbl < minConfidence.Value)
            {
                throw new XunitException($"Expected confidence >= {minConfidence.Value}, got {dbl}");
            }
        }
    }

    public static JsonNode MetadataToJson(Metadata metadata)
    {
        return Serialization.BuildMetadataNode(metadata);
    }

    public static JsonNode? LookupMetadata(JsonNode node, string path)
    {
        var current = node;
        foreach (var segment in path.Split('.', StringSplitOptions.RemoveEmptyEntries))
        {
            if (current is not JsonObject obj || !obj.TryGetPropertyValue(segment, out var next))
            {
                return null;
            }
            current = next!;
        }
        return current;
    }

    public static void AssertMetadata(JsonNode metadata, string path, string expectationJson)
    {
        var value = LookupMetadata(metadata, path);
        if (value is null)
        {
            throw new XunitException($"Metadata path {path} missing");
        }

        var spec = JsonNode.Parse(expectationJson)?.AsObject();
        if (spec is null)
        {
            throw new XunitException($"Invalid expectation for {path}: {expectationJson}");
        }

        if (spec.TryGetPropertyValue("eq", out var eq) && eq != null)
        {
            if (!JsonEquals(value, eq))
            {
                throw new XunitException($"Expected metadata {path} == {eq}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("gte", out var gte) && gte != null)
        {
            if (!CompareFloat(value, gte, true))
            {
                throw new XunitException($"Expected metadata {path} >= {gte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("lte", out var lte) && lte != null)
        {
            if (!CompareFloat(value, lte, false))
            {
                throw new XunitException($"Expected metadata {path} <= {lte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("contains", out var contains) && contains != null)
        {
            if (!ValueContains(value, contains))
            {
                throw new XunitException($"Expected metadata {path} to contain {contains}, got {value}");
            }
        }
    }

    private static bool JsonEquals(JsonNode a, JsonNode b)
    {
        if (a is JsonValue av && b is JsonValue bv)
        {
            if (av.TryGetValue<string>(out var aStr) && bv.TryGetValue<string>(out var bStr))
            {
                return aStr == bStr;
            }
            if (av.TryGetValue<double>(out var aNum) && bv.TryGetValue<double>(out var bNum))
            {
                return Math.Abs(aNum - bNum) < 1e-9;
            }
            if (av.TryGetValue<bool>(out var aBool) && bv.TryGetValue<bool>(out var bBool))
            {
                return aBool == bBool;
            }
        }

        if (a is JsonArray aa && b is JsonArray ba && aa.Count == ba.Count)
        {
            for (var i = 0; i < aa.Count; i++)
            {
                if (!JsonEquals(aa[i]!, ba[i]!))
                {
                    return false;
                }
            }
            return true;
        }

        return a.ToJsonString() == b.ToJsonString();
    }

    private static bool CompareFloat(JsonNode actual, JsonNode expected, bool gte)
    {
        try
        {
            double? actualVal = null;
            double? expectedVal = null;

            if (actual is JsonValue av)
            {
                if (av.TryGetValue<double>(out var d))
                    actualVal = d;
                else if (av.TryGetValue<int>(out var i))
                    actualVal = i;
            }

            if (expected is JsonValue ev)
            {
                if (ev.TryGetValue<double>(out var d))
                    expectedVal = d;
                else if (ev.TryGetValue<int>(out var i))
                    expectedVal = i;
            }

            if (actualVal is null || expectedVal is null)
                return false;

            return gte ? actualVal >= expectedVal : actualVal <= expectedVal;
        }
        catch
        {
            return false;
        }
    }

    private static bool ValueContains(JsonNode value, JsonNode contains)
    {
        if (value is JsonValue vv && contains is JsonValue cv)
        {
            if (vv.TryGetValue<string>(out var vStr) && cv.TryGetValue<string>(out var cStr))
            {
                return vStr.Contains(cStr, StringComparison.OrdinalIgnoreCase);
            }
        }

        // Check if array contains a single value
        if (value is JsonArray va && contains is JsonValue)
        {
            foreach (var vItem in va)
            {
                if (JsonEquals(vItem!, contains))
                {
                    return true;
                }
            }
            return false;
        }

        if (value is JsonArray vArr && contains is JsonArray ca)
        {
            foreach (var item in ca)
            {
                bool found = false;
                foreach (var vItem in vArr)
                {
                    if (JsonEquals(vItem!, item!))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                    return false;
            }
            return true;
        }

        return false;
    }
}
