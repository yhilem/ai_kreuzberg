use crate::fixtures::{Assertions, Fixture};
use anyhow::{Context, Result};
use camino::Utf8Path;
use itertools::Itertools;
use serde_json::{Map, Value};
use std::fmt::Write as _;
use std::fs;

const CSHARP_HELPERS_TEMPLATE: &str = r#"// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Nodes;
using Kreuzberg;
using Xunit;
using Xunit.Sdk;
using SkipException = Xunit.SkipException;

namespace Kreuzberg.E2E;

public static class TestHelpers
{
    private static readonly string WorkspaceRoot = ResolveWorkspaceRoot();
    private static readonly string TestDocuments = Path.Combine(WorkspaceRoot, "test_documents");

    static TestHelpers()
    {
        EnsureNativeLibraryLoaded();
    }

    private static string ResolveWorkspaceRoot()
    {
        var dir = AppContext.BaseDirectory;
        for (var i = 0; i < 8 && dir is not null; i++)
        {
            var candidate = dir!;
            if (File.Exists(Path.Combine(candidate, "Cargo.toml")) &&
                Directory.Exists(Path.Combine(candidate, "test_documents")))
            {
                return candidate;
            }
            dir = Directory.GetParent(candidate)?.FullName;
        }

        // Fallback to legacy two-levels-up resolution
        var cwd = Directory.GetCurrentDirectory();
        return Path.GetFullPath(Path.Combine(cwd, "..", ".."));
    }

    private static void EnsureNativeLibraryLoaded()
    {
        var candidates = new[]
        {
            Path.Combine(WorkspaceRoot, "target", "release", LibraryFileName()),
            Path.Combine(WorkspaceRoot, "target", "debug", LibraryFileName()),
        };

        foreach (var candidate in candidates)
        {
            if (File.Exists(candidate))
            {
                NativeLibrary.Load(candidate);
                return;
            }
        }

        throw new SkipException($"Native library not found. Expected at: {string.Join(", ", candidates)}");
    }

    private static string LibraryFileName()
    {
        if (OperatingSystem.IsWindows())
        {
            return "kreuzberg_ffi.dll";
        }
        if (OperatingSystem.IsMacOS())
        {
            return "libkreuzberg_ffi.dylib";
        }
        return "libkreuzberg_ffi.so";
    }

    public static string EnsureDocument(string relative, bool skipIfMissing)
    {
        var path = Path.Combine(TestDocuments, relative.Replace('/', Path.DirectorySeparatorChar));
        if (!File.Exists(path))
        {
            if (skipIfMissing)
            {
                throw new SkipException($"Missing document {path}");
            }
            throw new FileNotFoundException($"Document unavailable: {path}");
        }
        return path;
    }

    public static ExtractionConfig? BuildConfig(string? configJson)
    {
        if (string.IsNullOrWhiteSpace(configJson))
        {
            return null;
        }
        return Serialization.ParseConfig(configJson!);
    }

    public static ExtractionResult RunExtraction(string relativePath, string? configJson)
    {
        var documentPath = EnsureDocument(relativePath, true);
        var config = BuildConfig(configJson);
        return KreuzbergClient.ExtractFileSync(documentPath, config);
    }

    public static void AssertExpectedMime(ExtractionResult result, IEnumerable<string> expected)
    {
        var tokens = expected.ToArray();
        if (tokens.Length == 0)
        {
            return;
        }
        foreach (var token in tokens)
        {
            if (result.MimeType.Contains(token, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }
        }
        throw new XunitException($"Expected MIME to include one of [{string.Join(", ", tokens)}], got {result.MimeType}");
    }

    public static void AssertMinContentLength(ExtractionResult result, int minimum)
    {
        if (result.Content.Length < minimum)
        {
            throw new XunitException($"Expected content length >= {minimum}, got {result.Content.Length}");
        }
    }

    public static void AssertMaxContentLength(ExtractionResult result, int maximum)
    {
        if (result.Content.Length > maximum)
        {
            throw new XunitException($"Expected content length <= {maximum}, got {result.Content.Length}");
        }
    }

    public static void AssertContentContainsAny(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        foreach (var snippet in list)
        {
            if (lowered.Contains(snippet.ToLowerInvariant()))
            {
                return;
            }
        }
        throw new XunitException($"Expected content to contain any of [{string.Join(", ", list)}]");
    }

    public static void AssertContentContainsAll(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        var missing = list.Where(snippet => !lowered.Contains(snippet.ToLowerInvariant())).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected content to contain all snippets, missing: [{string.Join(", ", missing)}]");
        }
    }

    public static void AssertTableCount(ExtractionResult result, int? min, int? max)
    {
        var count = result.Tables?.Count ?? 0;
        if (min.HasValue && count < min.Value)
        {
            throw new XunitException($"Expected at least {min.Value} tables, got {count}");
        }
        if (max.HasValue && count > max.Value)
        {
            throw new XunitException($"Expected at most {max.Value} tables, got {count}");
        }
    }

    public static void AssertDetectedLanguages(ExtractionResult result, IEnumerable<string> expected, double? minConfidence)
    {
        var expectedList = expected.ToArray();
        if (expectedList.Length == 0)
        {
            return;
        }
        var langs = result.DetectedLanguages ?? new List<string>();
        if (langs.Count == 0)
        {
            throw new XunitException($"Expected detected languages {string.Join(", ", expectedList)} but field is empty");
        }

        var missing = expectedList.Where(lang => !langs.Any(candidate => string.Equals(candidate, lang, StringComparison.OrdinalIgnoreCase))).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected languages {string.Join(", ", expectedList)}, missing {string.Join(", ", missing)}");
        }

        if (minConfidence.HasValue)
        {
            var metadataNode = MetadataToJson(result.Metadata);
            var confidence = LookupMetadata(metadataNode, "confidence");
            if (confidence is JsonValue value && value.TryGetValue<double>(out var dbl) && dbl < minConfidence.Value)
            {
                throw new XunitException($"Expected confidence >= {minConfidence.Value}, got {dbl}");
            }
        }
    }

    public static JsonNode MetadataToJson(Metadata metadata)
    {
        return Serialization.BuildMetadataNode(metadata);
    }

    public static JsonNode? LookupMetadata(JsonNode node, string path)
    {
        var current = node;
        foreach (var segment in path.Split('.', StringSplitOptions.RemoveEmptyEntries))
        {
            if (current is not JsonObject obj || !obj.TryGetPropertyValue(segment, out var next))
            {
                return null;
            }
            current = next!;
        }
        return current;
    }

    public static void AssertMetadata(JsonNode metadata, string path, string expectationJson)
    {
        var value = LookupMetadata(metadata, path);
        if (value is null)
        {
            throw new XunitException($"Metadata path {path} missing");
        }

        var spec = JsonNode.Parse(expectationJson)?.AsObject();
        if (spec is null)
        {
            throw new XunitException($"Invalid expectation for {path}: {expectationJson}");
        }

        if (spec.TryGetPropertyValue("eq", out var eq))
        {
            if (!JsonEquals(value, eq))
            {
                throw new XunitException($"Expected metadata {path} == {eq}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("gte", out var gte))
        {
            if (!CompareFloat(value, gte, true))
            {
                throw new XunitException($"Expected metadata {path} >= {gte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("lte", out var lte))
        {
            if (!CompareFloat(value, lte, false))
            {
                throw new XunitException($"Expected metadata {path} <= {lte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("contains", out var contains))
        {
            if (!ValueContains(value, contains))
            {
                throw new XunitException($"Expected metadata {path} to contain {contains}, got {value}");
            }
        }
    }

    private static bool JsonEquals(JsonNode a, JsonNode b)
    {
        if (a is JsonValue av && b is JsonValue bv)
        {
            if (av.TryGetValue<string>(out var aStr) && bv.TryGetValue<string>(out var bStr))
            {
                return aStr == bStr;
            }
            if (av.TryGetValue<double>(out var aNum) && bv.TryGetValue<double>(out var bNum))
            {
                return Math.Abs(aNum - bNum) < 1e-9;
            }
            if (av.TryGetValue<bool>(out var aBool) && bv.TryGetValue<bool>(out var bBool))
            {
                return aBool == bBool;
            }
        }

        if (a is JsonArray aa && b is JsonArray ba && aa.Count == ba.Count)
        {
            for (var i = 0; i < aa.Count; i++)
            {
                if (!JsonEquals(aa[i]!, ba[i]!))
                {
                    return false;
                }
            }
            return true;
        }

        return a.ToJsonString() == b.ToJsonString();
    }

    private static bool CompareFloat(JsonNode actual, JsonNode expected, bool gte)
    {
        try
        {
            double? actualVal = null;
            double? expectedVal = null;

            if (actual is JsonValue av)
            {
                if (av.TryGetValue<double>(out var d))
                    actualVal = d;
                else if (av.TryGetValue<int>(out var i))
                    actualVal = i;
            }

            if (expected is JsonValue ev)
            {
                if (ev.TryGetValue<double>(out var d))
                    expectedVal = d;
                else if (ev.TryGetValue<int>(out var i))
                    expectedVal = i;
            }

            if (actualVal is null || expectedVal is null)
                return false;

            return gte ? actualVal >= expectedVal : actualVal <= expectedVal;
        }
        catch
        {
            return false;
        }
    }

    private static bool ValueContains(JsonNode value, JsonNode contains)
    {
        if (value is JsonValue vv && contains is JsonValue cv)
        {
            if (vv.TryGetValue<string>(out var vStr) && cv.TryGetValue<string>(out var cStr))
            {
                return vStr.Contains(cStr, StringComparison.OrdinalIgnoreCase);
            }
        }

        if (value is JsonArray va && contains is JsonValue cs && cs.TryGetValue<string>(out var needle))
        {
            foreach (var vItem in va)
            {
                if (vItem is JsonValue vv && vv.TryGetValue<string>(out var vStr) &&
                    vStr.Contains(needle, StringComparison.OrdinalIgnoreCase))
                {
                    return true;
                }
            }
            return false;
        }

        if (value is JsonArray va && contains is JsonArray ca)
        {
            foreach (var item in ca)
            {
                bool found = false;
                foreach (var vItem in va)
                {
                    if (JsonEquals(vItem!, item!))
                    {
                        found = true;
                        break;
                    }
                }
                if (!found)
                    return false;
            }
            return true;
        }

        return false;
    }
}
"#;

pub fn generate(fixtures: &[Fixture], output_root: &Utf8Path) -> Result<()> {
    let csharp_root = output_root.join("csharp");

    fs::create_dir_all(&csharp_root).context("Failed to create csharp output directory")?;

    clean_tests(&csharp_root)?;
    write_helpers(&csharp_root)?;

    let doc_fixtures: Vec<_> = fixtures.iter().filter(|f| f.is_document_extraction()).collect();

    let mut grouped = doc_fixtures
        .into_iter()
        .into_group_map_by(|fixture| fixture.category().to_string())
        .into_iter()
        .collect::<Vec<_>>();
    grouped.sort_by(|a, b| a.0.cmp(&b.0));

    for (category, mut fixtures) in grouped {
        fixtures.sort_by(|a, b| a.id.cmp(&b.id));
        let filename = format!("{}Tests.cs", sanitize_typename(&category));
        let content = render_category(&category, &fixtures)?;
        fs::write(csharp_root.join(&filename), content)
            .with_context(|| format!("Failed to write C# test file {filename}"))?;
    }

    Ok(())
}

fn clean_tests(dir: &Utf8Path) -> Result<()> {
    if !dir.exists() {
        return Ok(());
    }

    for entry in fs::read_dir(dir.as_std_path())? {
        let entry = entry?;
        if entry.path().extension().is_some_and(|ext| ext == "cs") {
            let name = entry.file_name().to_string_lossy().to_string();
            if name.ends_with("Tests.cs") || name == "Helpers.cs" {
                fs::remove_file(entry.path())?;
            }
        }
    }

    Ok(())
}

fn write_helpers(root: &Utf8Path) -> Result<()> {
    let helpers_path = root.join("Helpers.cs");
    fs::write(helpers_path.as_std_path(), CSHARP_HELPERS_TEMPLATE).context("Failed to write Helpers.cs")?;
    Ok(())
}

fn render_category(category: &str, fixtures: &[&Fixture]) -> Result<String> {
    let mut buffer = String::new();
    writeln!(buffer, "// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.")?;
    writeln!(buffer, "using System;")?;
    writeln!(buffer, "using System.Collections.Generic;")?;
    writeln!(buffer, "using Kreuzberg;")?;
    writeln!(buffer, "using Xunit;")?;
    writeln!(buffer, "using Kreuzberg.E2E;\n")?;

    let namespace = format!("Kreuzberg.E2E.{}", sanitize_typename(category));
    writeln!(buffer, "namespace {namespace} {{")?;
    writeln!(buffer, "    public class {}Tests", sanitize_typename(category))?;
    writeln!(buffer, "    {{")?;

    for fixture in fixtures {
        render_test(&mut buffer, fixture)?;
    }

    writeln!(buffer, "    }}")?;
    writeln!(buffer, "}}")?;

    Ok(buffer)
}

fn render_config_expression(config: &Map<String, Value>) -> Result<String> {
    if config.is_empty() {
        Ok("null".to_string())
    } else {
        let json = serde_json::to_string(&Value::Object(config.clone()))?;
        let escaped = json
            .replace('\\', "\\\\")
            .replace('"', "\\\"")
            .replace('\n', "\\n")
            .replace('\r', "\\r")
            .replace('\t', "\\t");
        Ok(format!("\"{}\"", escaped))
    }
}

fn render_test(buffer: &mut String, fixture: &Fixture) -> Result<()> {
    let test_name = sanitize_method_name(&fixture.id);
    writeln!(buffer, "        [Fact]")?;
    writeln!(buffer, "        public void {}()", test_name)?;
    writeln!(buffer, "        {{")?;

    let doc = fixture.document();
    let config_json = render_config_expression(&fixture.extraction().config)?;
    writeln!(
        buffer,
        "            var result = TestHelpers.RunExtraction(\"{}\", {});",
        escape_csharp_string(&doc.path),
        config_json
    )?;

    let assertions = fixture.assertions();
    render_assertions(buffer, &assertions)?;

    writeln!(buffer, "        }}\n")?;

    Ok(())
}

fn render_assertions(buffer: &mut String, assertions: &Assertions) -> Result<()> {
    if !assertions.expected_mime.is_empty() {
        let mimes = render_string_array(&assertions.expected_mime);
        writeln!(
            buffer,
            "            TestHelpers.AssertExpectedMime(result, new[] {{ {} }});",
            mimes
        )?;
    }

    if let Some(min) = assertions.min_content_length {
        writeln!(
            buffer,
            "            TestHelpers.AssertMinContentLength(result, {});",
            min
        )?;
    }

    if let Some(max) = assertions.max_content_length {
        writeln!(
            buffer,
            "            TestHelpers.AssertMaxContentLength(result, {});",
            max
        )?;
    }

    if !assertions.content_contains_any.is_empty() {
        let snippets = render_string_array(&assertions.content_contains_any);
        writeln!(
            buffer,
            "            TestHelpers.AssertContentContainsAny(result, new[] {{ {} }});",
            snippets
        )?;
    }

    if !assertions.content_contains_all.is_empty() {
        let snippets = render_string_array(&assertions.content_contains_all);
        writeln!(
            buffer,
            "            TestHelpers.AssertContentContainsAll(result, new[] {{ {} }});",
            snippets
        )?;
    }

    if let Some(tables) = assertions.tables.as_ref() {
        let min_str = tables
            .min
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        let max_str = tables
            .max
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertTableCount(result, {}, {});",
            min_str, max_str
        )?;
    }

    if let Some(languages) = assertions.detected_languages.as_ref() {
        let expected = render_string_array(&languages.expects);
        let min_conf = languages
            .min_confidence
            .map(|v| format!("{}", v))
            .unwrap_or_else(|| "null".to_string());
        writeln!(
            buffer,
            "            TestHelpers.AssertDetectedLanguages(result, new[] {{ {} }}, {});",
            expected, min_conf
        )?;
    }

    if !assertions.metadata.is_empty() {
        writeln!(
            buffer,
            "            var metadataNode = TestHelpers.MetadataToJson(result.Metadata);"
        )?;
        for (path, expectation) in &assertions.metadata {
            let expectation_json = render_csharp_metadata_expectation(expectation);
            writeln!(
                buffer,
                "            TestHelpers.AssertMetadata(metadataNode, \"{}\", @\"{}\");",
                escape_csharp_string(path),
                escape_csharp_verbatim_string(&expectation_json)
            )?;
        }
    }

    Ok(())
}

fn render_string_array(values: &[String]) -> String {
    values
        .iter()
        .map(|v| format!("\"{}\"", escape_csharp_string(v)))
        .collect::<Vec<_>>()
        .join(", ")
}

fn render_csharp_metadata_expectation(value: &Value) -> String {
    match value {
        Value::Object(map) => {
            if map.is_empty() {
                return "{}".to_string();
            }
            let parts = map
                .iter()
                .map(|(key, val)| format!("\"{}\": {}", escape_csharp_string(key), render_csharp_value(val)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("{{{}}}", parts)
        }
        _ => {
            let value_expr = render_csharp_value(value);
            format!("{{\"eq\": {}}}", value_expr)
        }
    }
}

fn render_csharp_value(value: &Value) -> String {
    match value {
        Value::Null => "null".to_string(),
        Value::Bool(b) => if *b { "true" } else { "false" }.to_string(),
        Value::Number(n) => n.to_string(),
        Value::String(s) => format!("\"{}\"", escape_csharp_string(s)),
        Value::Array(items) => {
            let parts = items.iter().map(render_csharp_value).collect::<Vec<_>>().join(", ");
            format!("[{}]", parts)
        }
        Value::Object(map) => {
            let parts = map
                .iter()
                .map(|(key, val)| format!("\"{}\": {}", escape_csharp_string(key), render_csharp_value(val)))
                .collect::<Vec<_>>()
                .join(", ");
            format!("{{{}}}", parts)
        }
    }
}

fn sanitize_typename(input: &str) -> String {
    input
        .chars()
        .map(|c| match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' => c,
            _ => '_',
        })
        .collect::<String>()
        .split('_')
        .filter(|s| !s.is_empty())
        .map(|s| {
            let mut chars = s.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join("")
}

fn sanitize_method_name(input: &str) -> String {
    input
        .chars()
        .map(|c| match c {
            'a'..='z' | 'A'..='Z' | '0'..='9' => c,
            _ => '_',
        })
        .collect::<String>()
        .split('_')
        .filter(|s| !s.is_empty())
        .map(|s| {
            let mut chars = s.chars();
            match chars.next() {
                Some(first) => first.to_uppercase().collect::<String>() + chars.as_str(),
                None => String::new(),
            }
        })
        .collect::<Vec<_>>()
        .join("")
}

fn escape_csharp_string(value: &str) -> String {
    value
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

fn escape_csharp_verbatim_string(value: &str) -> String {
    value.replace('"', "\"\"")
}
