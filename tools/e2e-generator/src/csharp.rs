use crate::fixtures::{Assertions, Fixture};
use anyhow::Result;
use camino::Utf8Path;
use itertools::Itertools;
use std::fmt::Write as _;
use std::fs;

const CS_PROJ_TEMPLATE: &str = r#"<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <IsPackable>false</IsPackable>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <ProjectReference Include="..\..\packages\csharp\Kreuzberg\Kreuzberg.csproj" />
    <PackageReference Include="xunit" Version="2.9.1" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.8.2">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.11.1" />
    <PackageReference Include="coverlet.collector" Version="6.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="Xunit.SkippableFact" Version="1.4.13" />
  </ItemGroup>
</Project>
"#;

const HELPERS_TEMPLATE: &str = r#"// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.Json;
using System.Text.Json.Nodes;
using Kreuzberg;
using Xunit;
using Xunit.Sdk;

namespace Kreuzberg.E2E;

public static class TestHelpers
{
    private static readonly string WorkspaceRoot = ResolveWorkspaceRoot();
    private static readonly string TestDocuments = Path.Combine(WorkspaceRoot, "test_documents");

    static TestHelpers()
    {
        EnsureNativeLibraryLoaded();
    }

    private static string ResolveWorkspaceRoot()
    {
        var cwd = Directory.GetCurrentDirectory();
        var root = Path.GetFullPath(Path.Combine(cwd, "..", ".."));
        return root;
    }

    private static void EnsureNativeLibraryLoaded()
    {
        var candidates = new[]
        {
            Path.Combine(WorkspaceRoot, "target", "release", LibraryFileName()),
            Path.Combine(WorkspaceRoot, "target", "debug", LibraryFileName()),
        };

        foreach (var candidate in candidates)
        {
            if (File.Exists(candidate))
            {
                NativeLibrary.Load(candidate);
                return;
            }
        }

        throw new SkipTestException($"Native library not found. Expected at: {string.Join(", ", candidates)}");
    }

    private static string LibraryFileName()
    {
        if (OperatingSystem.IsWindows())
        {
            return "kreuzberg_ffi.dll";
        }
        if (OperatingSystem.IsMacOS())
        {
            return "libkreuzberg_ffi.dylib";
        }
        return "libkreuzberg_ffi.so";
    }

    public static string EnsureDocument(string relative, bool skipIfMissing)
    {
        var path = Path.Combine(TestDocuments, relative.Replace('/', Path.DirectorySeparatorChar));
        if (!File.Exists(path))
        {
            if (skipIfMissing)
            {
                throw new SkipTestException($"Missing document {path}");
            }
            throw new FileNotFoundException($"Document unavailable: {path}");
        }
        return path;
    }

    public static ExtractionConfig? BuildConfig(string? configJson)
    {
        if (string.IsNullOrWhiteSpace(configJson))
        {
            return null;
        }
        return Serialization.ParseConfig(configJson!);
    }

    public static ExtractionResult RunExtraction(string relativePath, string? configJson)
    {
        var documentPath = EnsureDocument(relativePath, true);
        var config = BuildConfig(configJson);
        return KreuzbergClient.ExtractFileSync(documentPath, config);
    }

    public static void AssertExpectedMime(ExtractionResult result, IEnumerable<string> expected)
    {
        var tokens = expected.ToArray();
        if (tokens.Length == 0)
        {
            return;
        }
        foreach (var token in tokens)
        {
            if (result.MimeType.Contains(token, StringComparison.OrdinalIgnoreCase))
            {
                return;
            }
        }
        throw new XunitException($"Expected MIME to include one of [{string.Join(", ", tokens)}], got {result.MimeType}");
    }

    public static void AssertMinContentLength(ExtractionResult result, int minimum)
    {
        if (result.Content.Length < minimum)
        {
            throw new XunitException($"Expected content length >= {minimum}, got {result.Content.Length}");
        }
    }

    public static void AssertMaxContentLength(ExtractionResult result, int maximum)
    {
        if (result.Content.Length > maximum)
        {
            throw new XunitException($"Expected content length <= {maximum}, got {result.Content.Length}");
        }
    }

    public static void AssertContentContainsAny(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        foreach (var snippet in list)
        {
            if (lowered.Contains(snippet.ToLowerInvariant()))
            {
                return;
            }
        }
        throw new XunitException($"Expected content to contain any of [{string.Join(", ", list)}]");
    }

    public static void AssertContentContainsAll(ExtractionResult result, IEnumerable<string> snippets)
    {
        var list = snippets.ToArray();
        if (list.Length == 0)
        {
            return;
        }
        var lowered = result.Content.ToLowerInvariant();
        var missing = list.Where(snippet => !lowered.Contains(snippet.ToLowerInvariant())).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected content to contain all snippets, missing: [{string.Join(", ", missing)}]");
        }
    }

    public static void AssertTableCount(ExtractionResult result, int? min, int? max)
    {
        var count = result.Tables?.Count ?? 0;
        if (min.HasValue && count < min.Value)
        {
            throw new XunitException($"Expected at least {min.Value} tables, got {count}");
        }
        if (max.HasValue && count > max.Value)
        {
            throw new XunitException($"Expected at most {max.Value} tables, got {count}");
        }
    }

    public static void AssertDetectedLanguages(ExtractionResult result, IEnumerable<string> expected, double? minConfidence)
    {
        var expectedList = expected.ToArray();
        if (expectedList.Length == 0)
        {
            return;
        }
        var langs = result.DetectedLanguages ?? new List<string>();
        if (langs.Count == 0)
        {
            throw new XunitException($"Expected detected languages {string.Join(", ", expectedList)} but field is empty");
        }

        var missing = expectedList.Where(lang => !langs.Any(candidate => string.Equals(candidate, lang, StringComparison.OrdinalIgnoreCase))).ToArray();
        if (missing.Length > 0)
        {
            throw new XunitException($"Expected languages {string.Join(", ", expectedList)}, missing {string.Join(", ", missing)}");
        }

        if (minConfidence.HasValue)
        {
            var metadataNode = MetadataToJson(result.Metadata);
            var confidence = LookupMetadata(metadataNode, "confidence");
            if (confidence is JsonValue value && value.TryGetValue<double>(out var dbl) && dbl < minConfidence.Value)
            {
                throw new XunitException($"Expected confidence >= {minConfidence.Value}, got {dbl}");
            }
        }
    }

    public static JsonNode MetadataToJson(Metadata metadata)
    {
        return Serialization.BuildMetadataNode(metadata);
    }

    public static JsonNode? LookupMetadata(JsonNode node, string path)
    {
        var current = node;
        foreach (var segment in path.Split('.', StringSplitOptions.RemoveEmptyEntries))
        {
            if (current is not JsonObject obj || !obj.TryGetPropertyValue(segment, out var next))
            {
                return null;
            }
            current = next!;
        }
        return current;
    }

    public static void AssertMetadata(JsonNode metadata, string path, string expectationJson)
    {
        var value = LookupMetadata(metadata, path);
        if (value is null)
        {
            throw new XunitException($"Metadata path {path} missing");
        }

        var spec = JsonNode.Parse(expectationJson)?.AsObject();
        if (spec is null)
        {
            throw new XunitException($"Invalid expectation for {path}: {expectationJson}");
        }

        if (spec.TryGetPropertyValue("eq", out var eq))
        {
            if (!JsonEquals(value, eq))
            {
                throw new XunitException($"Expected metadata {path} == {eq}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("gte", out var gte))
        {
            if (!CompareFloat(value, gte, true))
            {
                throw new XunitException($"Expected metadata {path} >= {gte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("lte", out var lte))
        {
            if (!CompareFloat(value, lte, false))
            {
                throw new XunitException($"Expected metadata {path} <= {lte}, got {value}");
            }
        }
        if (spec.TryGetPropertyValue("contains", out var contains))
        {
            if (!ValueContains(value, contains))
            {
                throw new XunitException($"Expected metadata {path} to contain {contains}, got {value}");
            }
        }
    }

    private static bool JsonEquals(JsonNode a, JsonNode b)
    {
        if (a is JsonValue av && b is JsonValue bv)
        {
            if (av.TryGetValue<string>(out var aStr) && bv.TryGetValue<string>(out var bStr))
            {
                return aStr == bStr;
            }
            if (av.TryGetValue<double>(out var aNum) && bv.TryGetValue<double>(out var bNum))
            {
                return Math.Abs(aNum - bNum) < 1e-9;
            }
            if (av.TryGetValue<bool>(out var aBool) && bv.TryGetValue<bool>(out var bBool))
            {
                return aBool == bBool;
            }
        }

        if (a is JsonArray aa && b is JsonArray ba && aa.Count == ba.Count)
        {
            for (var i = 0; i < aa.Count; i++)
            {
                if (!JsonEquals(aa[i]!, ba[i]!))
                {
                    return false;
                }
            }
            return true;
        }

        return a.ToJsonString() == b.ToJsonString();
    }

    private static bool CompareFloat(JsonNode actual, JsonNode expected, bool gte)
    {
        if (!actual.TryGetValue<double>(out var act) || !expected.TryGetValue<double>(out var exp))
        {
            return false;
        }
        return gte ? act >= exp : act <= exp;
    }

    private static bool ValueContains(JsonNode value, JsonNode expected)
    {
        if (value is JsonArray array)
        {
            return array.Any(item => JsonEquals(item!, expected));
        }
        if (value is JsonValue val && val.TryGetValue<string>(out var str) && expected.TryGetValue<string>(out var sub))
        {
            return str.Contains(sub, StringComparison.OrdinalIgnoreCase);
        }
        return false;
    }
}
"#;

pub fn generate(fixtures: &[Fixture], output: &Utf8Path) -> Result<()> {
    let root = output.join("csharp");
    fs::create_dir_all(&root)?;
    fs::write(root.join("Kreuzberg.E2E.csproj"), CS_PROJ_TEMPLATE)?;
    fs::write(root.join("Helpers.cs"), HELPERS_TEMPLATE)?;

    for (category, chunk) in &fixtures.iter().chunk_by(|f| f.category().to_string()) {
        let fixtures: Vec<_> = chunk.collect();
        let content = build_category_tests(&category, &fixtures)?;
        let file_name = format!("{}_Tests.cs", category.to_uppercase());
        fs::write(root.join(file_name), content)?;
    }

    Ok(())
}

fn build_category_tests(category: &str, fixtures: &[&Fixture]) -> Result<String> {
    let mut content = String::new();
    let class_name = format!("{}Tests", to_pascal(category));

    writeln!(
        content,
        "// Code generated by kreuzberg-e2e-generator. DO NOT EDIT.\nusing System;\nusing System.Collections.Generic;\nusing Kreuzberg;\nusing Xunit;\nusing Kreuzberg.E2E;\n\nnamespace Kreuzberg.E2E.{ns} {{\n    public class {class_name}\n    {{",
        ns = to_pascal(category)
    )?;

    for fixture in fixtures {
        emit_test(&mut content, fixture)?;
    }

    writeln!(content, "    }}\n}}")?;
    Ok(content)
}

fn emit_test(output: &mut String, fixture: &Fixture) -> Result<()> {
    let method_name = format!("{}_{}", to_pascal(fixture.category()), to_pascal(&fixture.id));
    let config_json = fixture
        .extraction
        .as_ref()
        .and_then(|extraction| {
            if extraction.config.is_empty() {
                None
            } else {
                Some(serde_json::to_string(&extraction.config))
            }
        })
        .transpose()?;
    let assertions = fixture.assertions.as_ref();

    writeln!(output, "        [Fact]")?;
    writeln!(output, "        public void {name}()", name = method_name)?;
    writeln!(output, "        {{")?;
    writeln!(
        output,
        "            var result = TestHelpers.RunExtraction(\"{path}\", {config});",
        path = fixture
            .document
            .as_ref()
            .map(|doc| doc.path.as_str())
            .unwrap_or_default(),
        config = config_json.as_deref().map_or_else(
            || "null".to_string(),
            |json| format!("@\"{}\"", escape_csharp_literal(json))
        )
    )?;

    if let Some(assertions) = assertions {
        emit_assertions(output, assertions)?;
    }

    writeln!(output, "        }}\n")?;
    Ok(())
}

fn emit_assertions(output: &mut String, assertions: &Assertions) -> Result<()> {
    if !assertions.expected_mime.is_empty() {
        let mime_list = assertions.expected_mime.iter().map(|m| format!("\"{}\"", m)).join(", ");
        writeln!(
            output,
            "            TestHelpers.AssertExpectedMime(result, new[] {{ {mime_list} }});"
        )?;
    }

    if let Some(min) = assertions.min_content_length {
        writeln!(output, "            TestHelpers.AssertMinContentLength(result, {min});")?;
    }

    if let Some(max) = assertions.max_content_length {
        writeln!(output, "            TestHelpers.AssertMaxContentLength(result, {max});")?;
    }

    if !assertions.content_contains_any.is_empty() {
        let snippets = assertions
            .content_contains_any
            .iter()
            .map(|s| format!("\"{}\"", s.replace('"', "\\\"")))
            .join(", ");
        writeln!(
            output,
            "            TestHelpers.AssertContentContainsAny(result, new[] {{ {snippets} }});"
        )?;
    }

    if !assertions.content_contains_all.is_empty() {
        let snippets = assertions
            .content_contains_all
            .iter()
            .map(|s| format!("\"{}\"", s.replace('"', "\\\"")))
            .join(", ");
        writeln!(
            output,
            "            TestHelpers.AssertContentContainsAll(result, new[] {{ {snippets} }});"
        )?;
    }

    if let Some(tables) = &assertions.tables {
        let min = tables.min.map_or("null".to_string(), |v| v.to_string());
        let max = tables.max.map_or("null".to_string(), |v| v.to_string());
        writeln!(
            output,
            "            TestHelpers.AssertTableCount(result, {min}, {max});"
        )?;
    }

    if let Some(lang) = &assertions.detected_languages {
        let langs = lang.expects.iter().map(|s| format!("\"{}\"", s)).join(", ");
        let min_conf = lang.min_confidence.map_or("null".to_string(), |v| format!("{v}d"));
        writeln!(
            output,
            "            TestHelpers.AssertDetectedLanguages(result, new[] {{ {langs} }}, {min_conf});"
        )?;
    }

    if !assertions.metadata.is_empty() {
        writeln!(
            output,
            "            var metadataNode = TestHelpers.MetadataToJson(result.Metadata);"
        )?;
        for (path, expectation) in &assertions.metadata {
            let expectation_json = serde_json::to_string(expectation)?;
            writeln!(
                output,
                "            TestHelpers.AssertMetadata(metadataNode, \"{path}\", @\"{expected}\");",
                path = path,
                expected = escape_csharp_literal(&expectation_json)
            )?;
        }
    }

    Ok(())
}

fn to_pascal(input: &str) -> String {
    let mut output = String::new();
    let mut capitalize = true;
    for ch in input.chars() {
        if ch.is_alphanumeric() {
            if capitalize {
                for up in ch.to_uppercase() {
                    output.push(up);
                }
                capitalize = false;
            } else {
                output.push(ch);
            }
        } else {
            capitalize = true;
        }
    }

    if output.is_empty() { "E2E".to_string() } else { output }
}

fn escape_csharp_literal(raw: &str) -> String {
    raw.replace('"', "\"\"")
}
